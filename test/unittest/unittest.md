## Unit Test
[마틴 파울러 UnitTest](https://martinfowler.com/bliki/UnitTest.html)  
### 단위 테스트에 대한 공통 요소
단위 테스트는 소프트웨어 시스템의 작은 부분에 초점을 맞춘 저수준이라는 개념이 있습니다.  
두 번째로 단위 테스트는 일반적으로 프로그래머가 정규 도구를 사용하여 작성합니다. 유일한 차이점은 일종의 단위 테스트 프레임워크를 사용한다는 것입니다.    
세 번째로 단위 테스트는 다른 종류의 테스트보다 훨씬 빠를 것으로 예상됩니다.  
  
### 차이점
따라서 몇 가지 공통 요소가 있지만 차이점도 있습니다.  
한 가지 차이점은 사람들이 단위로 간주하는 것입니다. 객체 지향 디자인은 클래스를 단위로 취급하는 경향이 있으며, 절차적 또는 기능적 접근 방식은 단일 기능을 단위로 간주할 수 있습니다. 그러나 실제로는 상황에 따라 다릅니다.  
팀은 시스템과 테스트에 대한 이해를 목적으로 단위가 되는 것이 무엇인지 결정합니다. 나는 단위가 하나의 클래스라는 개념으로 시작하지만 종종 밀접하게 관련된 여러 클래스를 취하여 하나의 단위로 취급합니다. 드물게 클래스의 메서드 하위 집합을 하나의 단위로 사용할 수 있습니다. 그러나 당신이 그것을 정의하는 것은 별로 중요하지 않습니다.  
  
### Solitary or Sociable?
![](https://martinfowler.com/bliki/images/unitTest/isolate.png)  
더 중요한 차이점은 테스트 중인 단위가 사교적(Sociable)이어야 하는지 아니면 혼자 있어야(Solitary) 하는지 여부입니다.  
주문 클래스의 가격 방법을 테스트한다고 상상해 보십시오. price 메서드는 제품 및 고객 클래스에 대한 일부 함수를 호출해야 합니다. 단위 테스트를 단독으로 수행하려는 경우 여기에서 실제 제품 또는 고객 클래스를 사용하지 않는 것이 좋습니다. 고객 클래스의 오류로 인해 주문 클래스의 테스트가 실패할 수 있기 때문입니다. 대신 공동 작업자를 위해 TestDoubles를 사용합니다.  
참고로, TestDobules는 테스트를 진행하기 어려운 경우 이를 대신해 테스트를 진행할 수 있도록 만들어주는 객체를 말합니다.  
  
그러나 모든 단위 테스터가 단독 단위 테스트를 사용하는 것은 아닙니다.    
실제로 90년대에 xunit 테스트가 시작되었을 때 우리는 공동 작업자와의 통신이 어색하지 않은 한(예: 원격 신용 카드 확인 시스템) 단독으로 시도하지 않았습니다. 인접한 테스트가 실패하더라도 실제 결함을 추적하는 것은 어렵지 않았습니다. 그래서 우리는 테스트를 사교적으로 허용해도 실제로 문제가 발생하지 않는다고 느꼈습니다. 실제로 사교적인 단위 테스트를 사용하는 것은 우리가 "단위 테스트"라는 용어를 사용하는 것에 대해 비판을 받은 이유 중 하나였습니다. 이러한 테스트는 단일 단위의 동작에 대한 테스트이기 때문에 "단위 테스트"라는 용어가 적절하다고 생각합니다. 해당 장치 이외의 모든 것이 올바르게 작동한다고 가정하고 테스트를 작성합니다.  
  
2000년대에 xunit 테스트가 대중화되면서 적어도 일부 사람들에게는 단독(solitary) 테스트라는 개념이 다시 돌아왔습니다. 우리는 모킹을 지원하는 모의 객체와 프레임워크의 등장을 보았습니다. xunit 테스팅의 두 가지 학교가 개발되었는데, 저는 이를 클래식 스타일과 모의객체 스타일이라고 부릅니다. 두 스타일의 차이점 중 하나는 모의객체는 단독 단위 테스트를 고집하는 반면 고전주의자는 사교적인 테스트를 선호한다는 것입니다. 오늘날 저는 두 가지 스타일의 xunit 테스터를 알고 존경합니다(개인적으로 저는 고전적인 스타일을 유지했습니다). 저와 같은 고전적인 테스터도 어색한 협업이 있을 때 테스트 더블을 사용합니다.  
원격 서비스와 통신할 때 비결정성을 제거하는 데 매우 중요합니다. 실제로 일부 고전주의 xunit 테스터는 데이터베이스나 파일 시스템과 같은 외부 리소스와의 모든 협업에서 Testdouble을 사용해야 한다고 주장합니다. 부분적으로는 비결정론적 위험 때문이고 부분적으로는 속도 때문입니다. 이것이 유용한 지침이라고 생각하지만 절대적인 규칙으로 외부 리소스에 TestDouble을 사용하는 것은 아닙니다. 리소스와의 통신이 충분히 안정적이고 빠르다면 단위 테스트에서 수행하지 않을 이유가 없습니다.  
  
### speed
단위 테스트의 공통 속성(프로그래머가 직접 수행하는 작은 범위, 빠른 속도)은 프로그래밍할 때 매우 자주 실행할 수 있음을 의미합니다.  
실제로 이것은 SelfTestingCode의 주요 특징 중 하나입니다. 이 상황에서 프로그래머는 코드를 변경한 후 단위 테스트를 실행합니다. 컴파일할 가치가 있는 코드가 있을 때마다 1분에 여러 번 단위 테스트를 실행할 수 있습니다. 실수로 무언가를 깨뜨리면 바로 알고 싶어서 이렇게 합니다. 마지막 변경으로 결함을 도입했다면 멀리 볼 필요가 없기 때문에 버그를 발견하기가 훨씬 쉽습니다.  
  
단위 테스트를 너무 자주 실행하면 모든 단위 테스트를 실행하지 못할 수 있습니다.  
일반적으로 현재 작업 중인 코드 부분에서 작동하는 테스트만 실행하면 됩니다. 평소와 같이 테스트 스위트를 실행하는 데 걸리는 시간과 테스트의 깊이를 절충합니다.  
참고로, 테스트 스위트(test suite)는 test case를 관계별로 묶어놓은 것을 의미합니다.  
  
CI를 사용하는 경우 그 일부로 테스트 스위트를 실행해야 합니다. 내가 커밋 스위트라고 부르는 이 스위트는 모든 단위 테스트를 포함하는 것이 일반적입니다. 몇 개의 BroadStackTest도 포함될 수 있습니다. 프로그래머로서 하루에 여러 번 이 커밋 스위트를 실행해야 합니다. 물론 버전 제어에 대한 공유 커밋 전에는 물론 다른 기회가 있을 때(휴식을 취하거나 회의에 가야 할 때)도 마찬가지입니다. 커밋 모음이 빠를수록 더 자주 실행할 수 있습니다.  
  
사람들마다 단위 테스트 및 테스트 스위트의 속도에 대한 표준이 다릅니다. David Heinemeier Hansson은 몇 초가 걸리는 컴파일 스위트와 몇 분이 걸리는 커밋 스위트에 만족합니다. Gary Bernhardt는 약 300ms의 컴파일 스위트를 고집하면서 견딜 수 없을 정도로 느리다는 것을 알게 되었고 Dan Bodart는 그의 커밋 스위트가 10초 이상 되는 것을 원하지 않았습니다.  
  
여기에 절대적인 답은 없다고 생각합니다. 개인적으로 나는 1초 이하 또는 몇 초인 컴파일 스위트 사이의 차이를 느끼지 못합니다. 저는 커밋 스위트가 10분 이내에 실행되어야 한다는 Kent Beck의 경험 법칙을 좋아합니다. 그러나 실제 요점은 테스트 도구 모음을 충분히 자주 실행하여 낙심하지 않을 만큼 충분히 빠르게 실행해야 한다는 것입니다. 그리고 그들이 버그를 발견했을 때 당신이 그것을 빨리 발견할 수 있도록 살펴볼 충분한 양의 작업이 있을 정도로 자주 충분합니다.
