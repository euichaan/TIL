# 변경 감지

JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다.

엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(dirty checking)이라 한다.

1. flush()
    - **트랜잭션을 커밋**하면 엔티티 매니저 내부에서 먼저 플러시(flush())가 호출된다.
2. 엔티티와 스냅샷 비교
    - 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.
3. 쓰기 지연 SQL 저장소에 UPDATE SQL 생성 
    - 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.
4. flush
    - 쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.
5. commit 
    - 데이터베이스 트랜잭션을 커밋한다.

변경 감지는 영속 상태의 엔티티에만 적용된다.

JPA의 기본 전략은 **엔티티의 모든 필드**를 업데이트한다.

```sql
UPDATE MEMBER
SET
    NAME=?,
    AGE=?,
    GRADE=?,
    ...
WHERE
    id=? 
```

모든 필드를 업데이트하면 데이터베이스에 보내는 데이터 전송량이 증가하는 단점이 있지만, 다음과 같은 장점으로 인해 모든 필드를 업데이트한다.

- 모든 필드를 사용하면 수정 쿼리가 항상 같다. 따라서 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다.
- 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.

@DynamicUpdate를 사용하면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성할 수 있다.

> 상황에 따라 다르지만 칼럼이 대략 30개 이상이 되면 @DynamicUpdate를 사용한 동적 쿼리 수정이 빠르다고 한다. 참고로 한 테이블에 컬럼이 30개 이상이라면 테이블 설계상 책임이 적절히 분리되지 않았을 가능성이 높다.
> 

### 플러시

**플러시(flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.**

플러시를 실행하면 구체적으로 다음과 같은 일이 일어난다.

1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

em.flush()
트랜잭션 커밋 시
JPQL 쿼리 실행 시

플러시가 호출된다.

~~find()~~ 메서드를 호출할 때는 플러시가 실행되지 않는다.