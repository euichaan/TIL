# 12월 12일
## c++ 함수
```c++
#include <algorithm>
void fill (ForwardIterator first, ForwardIterator last, const T& val);
```
- first : 채우고자 하는 자료구조의 시작위치 iterator 
- last : 채우고자 하는 자료구조의 끝위치 iterator이며 `last는 포함하지 않습니다`  
- val : first부터 last전까지 채우고자 하는 값으로 어떤 객체나 자료형을 넘겨줘도 템플릿 T에 의해 가능합니다  
  
# 12월 13일
## 객체의 생성
new 키워드는 클래스의 인스턴스를 생성하기 위해 사용됩니다.  
인스턴스란, 해당 클래스의 구조로 `컴퓨터 저장공간에 할당된 실체`를 의미합니다. 여기서 클래스란 `속성`과 `행위`로 구성된 일종의 설계도입니다.  
OOP에서 객체는 클래스와 인스턴스를 포함한 개념입니다.  
  
```java
String s = new String();
String name = "Kenneth";
Person p = new Person();
```
인스턴스화(instantiation)는 새로운 객체를 위해 힙 영역의 메모리를 할당하고, 변수에 할당된 메모리주소(reference)를 반환합니다.  
- 객체의 생성자가 실행됩니다.  
- 런타임에 새로운 객체를 위해 힙 영역의 메모리를 할당합니다.  
- 새로운 객체를 위해 힙 영역에 할당된 메모리 주소는 스택 영역의 변수에 저장됩니다.  

```java
String s = new String();
```
1. 메모리가 할당되며, 할당된 메모리의 주소(reference)가 반환됩니다.  
2. 필드가 기본값으로 초기화됩니다.  
3. super또는 this를 포함한 생성자가 호출됩니다.  

## 오버로딩과 오버라이딩  
오버로딩 (overloading) : 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 `매개변수의 개수 또는 타입`이 다르면,  
같은 이름을 사용해서 메서드를 정의할 수 있습니다.  

메서드의 이름이 같고, 메개변수의 개수나 타입이 달라야 합니다. '리턴 값만' 다른 것은 오버로딩 할 수 없습니다.  
또한 접근 제어자만 다르게 한다고 오버로딩이 가능하지 않습니다.   

오버라이딩 (overriding) : 부모 클래스의 메서드 동작 방법을 변경`(재정의)`하여 우선적으로 사용하는 것입니다.  

## c++ STL
`max_element`는 가장 큰 원소가 있는 곳의 포인터를 반환하는 STL. *를 달아 그 주소의 값을 반환할 수 있습니다.  
```c++
int solution3(int arr[]) {
  return *max_element(arr, arr + 4);
}
```

## 트랜잭션
트랜잭션이란 `한꺼번에 모두 수행되어야 할 일련의 연산들` 또는 `데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위` 입니다.  
  
# 12월 14일
## parseInt와 valueOf
parseInt는 String 타입의 숫자를 int 타입의 문자열로 변환해줍니다.    
문자가 섞여있다면 `NumberFormatException`이 발생합니다.  
  
parseInt의 리턴타입은 기본 자료형(int)입니다.  
valueOf의 리턴타입은 객체입니다.  









  



