# Servlet & Servlet Container
## 서블릿(Servlet)이란?
자바로 HTTP 요청을 처리하는 프로그램을 만들 떼 서블릿을 사용한다.  
서블릿은 자바 표준이다. JaKarta EE(== Java EE) 스펙이다.  
  
스프링만 썼는데?  
스프링 MVC는 서블릿 기반으로 작동한다.  
- DispatcherServlet  
- Filter  
  
서블릿만 써도 웹 서비스 개발이 가능한데 왜 스프링을 쓰는가?  
- 스프링은 초기 J2EE 스펙이 사용하기 복잡해서 등장했다.  
- 서블릿을 활용한 J2EE 만으로는 엔터프라이즈 애플리케이션을 운영하기 어렵다.  
  
서블릿 기반으로 `스프링 MVC`가 동작하기 때문에 원리는 알아야 한다.  
  
서블릿 표준에 맞춰 구현할 수 있도록 인터페이스가 제공된다.  
init(), service(), destroy()  
  
## 서블릿 생명주기(life-cycle)
init(), service(), destroy() 메서드를 `라이프 사이클(life-cycle)` 메서드라고 부른다.  
![](https://www.oreilly.com/api/v2/epubs/9780596516680/files/httpatomoreillycomsourceoreillyimages2242487.png.jpg)  
```
서블릿 일생은 사실 매우 간단합니다. 왜냐하면 서블릿은 오직 하나의 중요한 상태를 가지기 때문입니다. 여기서 중요한 상태는 초기화(initialized)를 말합니다.
서블릿이 초기화되지 않았다는 말은, 초기화되는 중(생성자를 실행하거나 init() 메서드를 실행하지 않았거나)이거나, 아니면 소멸하는 중(destroy() 메서드를 실행)이거나,
그것도 아니면 존재하지 않음(does not exist) 중 하나라는 말입니다.
```
Web Container는 톰캣이라고 생각하면 된다. 톰캣이 실행될 때 서블릿 클래스를 로딩한다. (서블릿 클래스는 서블릿 클래스로 개발자가 구현한 서블릿)  
기본 생성자를 사용해서 서블릿 객체로 만든 후 init() 메서드를 실행한다(한번만). 톰캣은 클라이언트의 요청을 받아서 처리하는 역할을 한다. 요청을 처리할 때 서블릿의 service 메서드가 호출된다.  
service메서드에 처리하고 싶은 비즈니스 로직을 넣으면 된다. destroy() 메서드는 서블릿이 죽기 전에 가지고 있는 자원들을 깨끗이 정리할 기회를 준다. init() 처럼 한 번만 호출된다.  
  
## 서블릿과 서블릿 컨테이너
서블릿은 컨테이너가 관리합니다.(컨테이너는 톰캣을 생각하면 된다. Servlet Container, WAS라고도 부른다.)  
[요청과 응답 그림으로 이해하기](https://www.oreilly.com/library/view/head-first-servlets/9780596516680/ch02s04.html)  
  
서블릿 컨테이너는 서블릿을 각각의 요청별로 생성해둔다. 예를 들어 웹 서비스가 로그인, 로그아웃, 글 읽기, 글 쓰기 이 4개의 요청을 처리해야한다면, 서블릿 컨테이너는 4개의 개별적인 서블릿 객체를 생성해둔다. 각 요청별 서블릿은 단 하나만 생성한다. **그렇다고, 서블릿 자체가 싱글톤이라는 이야기는 아니다.**    

클라이언트로부터 서블릿 컨테이너가 요청을 받으면, `Request 객체, Response 객체`를 생성한다. 그리고 URL에 따라 요청을 처리할 적절한 서블릿을 찾는다. 서블릿 컨테이너는 찾은 서블릿의 service() 메소드를 실행하는데 이때 생성해둔 Request, Response 객체를 파라미터로 함께 전달한다. 서블릿이 요청을 처리하면, `Response 객체`를 다시 서블릿 컨테이너에게 전달하고, 사용자에게 응답한다.

이때, **service() 메소드는 별개의 쓰레드로 실행된다.** 즉, 서블릿 객체는 하나이지만 여러개의 쓰레드에서 실행된다. 이것이 웹 서버가 여러 사용자의 요청을 동시에 처리할 수 있는 이유이다. 서블릿 객체는 하나인데, 쓰레드가 여러개라면 동시성 이슈가 발생할 가능성이 있다. **이런 구조상 Thread-Safe를 위해 서블릿은 상태(인스턴스 및 Static 변수 등)를 가지면 안된다.** 서블릿이 상태를 가지면, 공유 자원으로 인한 동시성 이슈가 발생해 사용자의 민감한 정보가 다른 사용자에게 노출되는 일이 발생할수도 있다.

요청을 모두 처리했다면 사용된 쓰레드와 Request, Response 객체는 JVM에게 반납한다. 이때 Servlet은 계속 살아있다. 

## 서블릿 하나로 다수 요청을 처리한다.
![](https://www.oreilly.com/api/v2/epubs/9780596516680/files/httpatomoreillycomsourceoreillyimages2242499.png.jpg)  
**컨테이너는 서블릿 하나에 대한 다수의 요청을 처리하기 위하여 다수의 스레드를 실행하지 다수의 인스턴스를 만들지는 않습니다.**  
또한 클라이언트 요청을 처리하려고 요청마다 새로운 `Request, Response` 객체를 생성합니다.  
  
클라이언트는 자신의 요청을 처리할 자신만의 스레드를 가집니다. 컨테이너는 스레드마다 `Request, Response` 객체를 생성합니다.  
  
```
인스턴스 변수, static 변수 등을 서블릿에 작성하면 공유가 된다. 따라서 상태를 가지면 안된다.
```
  
## 필터(Filter)
요청, 응답에 추가적인 작업을 하고 싶을 때 필터를 사용한다.  
필터도 표준에 맞춰 구현할 수 있도록 인터페이스가 제공된다.  
요청, 응답에 추가 작업을 하고 싶다면 `doFilter()` 메서드를 구현하면 된다.  
  
``` 
HTTP 요청 -> WAS(Servlet Container) -> 필터 -> 서블릿 -> 컨트롤러
```