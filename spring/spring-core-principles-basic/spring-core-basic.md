# 스프링 핵심 원리 - 기본편
EJB : Enterprise Java Beans 예전 자바 표준  
복잡하고 어려운데, 느린 단점.  
  
하이버네이트 : EJB 엔티티빈 기술을 대체. JPA(Java Persistence API) 새로운 표준 정의  
  
표준 인터페이스 JPA를 구현한 하이버네이트, EclipseLink, 기타 등등..  
  
2014년 스프링 부트 1.0 출시  
  
## 스프링 프레임워크 : 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크
핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타  
웹 기술 : 스프링 MVC, 스프링 WebFlux  
데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원  
기술 통합 : 캐시, 이메일, 원격 접근, 스케줄링  
테스트 : 스프링 기반 테스트 지원  
언어: 코틀린, 그루비  
- 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용  
  
## 스프링 부트  
스프링을 편리하게 사용할 수 있도록 지원.  
단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성  
Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨  
손쉬운 빌드 구성을 위한 starter 종속성 제공  
스프링과 3rd party(외부) 라이브러리 자동 구성  
메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공  
관례에 의한 간결한 설정  
  
## 스프링 단어?
스프링이라는 단어는 문맥에 따라 다르게 사용된다.  
- 스프링 DI 컨테이너 기술(Bean 관리 등)  
- 스프링 프레임워크  
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계  
  
## 스프링의 진짜 핵심
- 스프링은 자바 언어 기반의 프레임워크  
- 자바 언어의 가장 큰 특징 - 객체 지향 언어  
- 스프링은 **객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크**    
- 스프링은 **좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크**  
  
기존 EJB는 객체 지향의 장점들을 잃어버림.  
스프링은 제대로 된 객체지향 프로그램을 할 수 있도록 도와주는 도구.  
  
## 좋은 객체 지향 프로그래밍?
- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위,  
즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다(협력)  
- 객체 지향 프로그래밍은 프로그램을 유연하고 변경에 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.  
  
유연하고 변경이 용이? - 다형성(Polymorphism)  
다형성을 실세계 비유하면 이해하기에는 좋다.  
  
## 역할(인터페이스)과 구현(구현체)으로 세상을 구분
운전자 - 자동차  
운전자는 자동차의 인터페이스(역할)에 대해서만 의존을 하고있다.  
운전자(Clinet)는 자동차의 내부 구조를 몰라도 된다.  
클라이언트에 영향을 주지 않고 새로운 기능을 제공할 수 있다.  
  
로미오와 줄리엣 공연  
역할 - 로미오 역할, 줄리엣 역할  
구현 - 장동건, 원빈, 김태희, 송혜교  
배우는 대체가 가능해야 한다. 유연하고 변경에 용이하다.  
  
## 역할과 구현을 분리
역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.  
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.  
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.  
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.  
- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.  
  
## 역할과 구현을 분리 - 자바 언어
자바 언어의 다형성을 활용  
- 역할 = 인터페이스  
- 구현 = 인터페이스를 구현한 클래스, 구현 객체  
객체를 설계할 때 역할과 구현을 명확히 분리  
객체 설계 시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기.  
  
## 객체의 협력이라는 관계부터 생각
혼자 있는 객체는 없다.  
클라이언트 : 요청, 서버 : 응답  
수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.  
  
## 자바 언어의 다형성
오버라이딩 된 메서드가 실행  
다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다.  
의존한다 == 알고 있다  
  
인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.  
다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함  
클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.  
  
## 역할과 구현의 분리 - 한계
인터페이스 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.  
인터페이스를 안정적으로 잘 설계하는 것이 중요.  
  
# 스프링과 객체 지향
다형성이 가장 중요하다!  
스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.  
스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰  
수 있도록 지원한다.  
  
다형성 + SOLID  
다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.  
다형성 만으로는 OCP, DIP를 지킬 수 없다.  
뭔가 더 필요하다.  
  
# 객체 지향 설계와 스프링
스프링은 다음 기술로 다형성 + OCP, DIP 를 가능하게 지원한다.  
 - DI(Dependency Injection) : 의존관계, 의존성 주입  
 - DI 컨테이너 제공. (Java 객체들을 컨테이너 안에 넣어두고 이 안에서 의존관계 연결, 주입)  
클라이언트 코드의 변경 없이 기능 확장  
쉽게 부품을 교체하듯이 개발  
  
순수하게 OCP, DIP 원칙을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게 된다.(DI 컨테이너)  
  
애플리케이션 설계도 공연을 설계 하듯이 배역(역할)만 만들어두고, 배우(구현)은 언제든지 유연하게 변경  
할 수 있도록 만드는 것이 좋은 객체 지향 설계다.  
이상적으로는 모든 설계에 인터페이스를 부여하자.  
  
하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.  
기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서  
인터페이스를 도입하는 것도 방법이다.  
  
인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계하면 된다.  
  
회원 클래스 다이어그램 : 정적
서버가 실제 떴을 때 서버가 실제 사용하는 new 한 인스턴스 끼리의 참조 : 회원 객체 다이어그램(동적)  
  
## OCP 원칙 : Open/closed principle  
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.  

## DIP 원칙 : Dependency Inversion  principle  
프로그래머는 추상화에 의존해야지, 구체화에 위존하면 안된다. 쉽게 말해 구현 클래스가 아닌  
인터페이스에 의존하라는 뜻  

## 주문 서비스 개발  
1. 주문 생성 : 클라이언트는 주문 서비스에 주문 생성을 요청한다.  
2. 회원 조회 : 할인을 위해서는 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원 조회한다.  
3. 할인 적용 : 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다.  
4. 주문 결과 반환 : 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.  
  
역할과 구현을 분리해서 자유롭게 구현 객체를 조립할 수 있게 설계했다.  
  
객체 다이어그램은 실제 new해서 서버를 띄워 동적으로 연관관계가 만들어지는 것.  
협력 관계를 그대로 재사용 할 수 있다.  
  
할인 정책을 변경하려면 클라이언트인 OrderServiceImpl 코드를 고쳐야 한다.  
DIP : 추상(인터페이스) 뿐만 아니라 구체(구현) 클래스에도 의존하고 있다.  
  
그래서 FixDiscountPolicy를 RateDiscountPolicy로 변경하는 순간 OrderServiceImpl의 소스 코드도 함께 변경해야 한다.(OCP 위반)  
  
# DIP, OCP를 지키려면..
DIP를 위반하지 않도록 인터페이스에만 의존하도록 의존관계를 변경하면 된다.  
구현체가 없는데 어떻게 코드를 실행할 수 있을까?  
=> 누군가가 클라이언트인 `OrderServceImpl`에 `DiscountPolicy`의 구현 객체를 대신 생성하고 주입해주어야 한다.  
  
## 관심사의 분리
역할에 맞는 구현을 선택하는 것은 누가 하는가?  
이전 코드는 마치 로미오 역할(인터페이스)을 하는 디카프리오(구현체)가 줄리엣 역할(인터페이스)을 하는  
여자 주인공(구현체)을 직접 초빙하는 것과 같다.  
  
AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성한다.  
AppConfig는 생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결)해준다.  
  
설계 변경으로 MemberServiceImpl은 MemoryMemberRepository를 의존하지 않고 MemberRepository 인터페이스만 의존  
- MemberServiceImpl 입장에서 생성자를 통해 어떤 구현 객체가 들어올지(주입될지)는 알 수 없다.  
- MemberServiceImpl의 생성자를 통해서 어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정된다.  
- MemberServiceImpl은 이제부터 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중하면 된다.  
  
DIP 완성 : MemberServiceImpl은 MemberRepository인 추상에만 의존하면 된다. 구체 클래스를 몰라도 된다.  
관심사의 분리 : 객체를 생성하고 연결하는 역할(AppConfig)과 실행하는 역할이 명확히 분리되었다.  
  
appConfig 객체는 memoryMemberRepository 객체를 생성하고 그 참조값을 memberServiceImpl을 생성하면서 생성자로 전달한다.  
클라이언트인 memberServiceImpl 입장에서 보면 의존관계를 마치 외부에서 주입해주는 것 같다고 해서 DI라 한다.  
DI = Dependency Injection, 의존관계 주입 또는 의존성 주입  
  
OrderSerivceImpl은 기능을 실행하는 책임만 지면 된다.  
  
AppConfig에서 할인 정책을 담당하는 구현을 FixDiscountPolicy -> RateDiscountPolicy 객체로 변경했다.  
할인 정책을 변경해도, AppConfig만 변경하면 된다.  
구성 영역은 당연히 변경된다.  
  
OCP : 확장에는 열려있고, 변경에는 닫혀있다. FixDiscountPolicy를 RateDiscountPolicy를 변경했음에도 클라이언트 코드를 변경하지 않음.  
  
AppConfig는 구현 객체를 생성하고, 연결하는 책임  
역할과 구현을 분리  
AppConfig의 등장으로 애플리케이션이 크게 사용 영역과, 객체를 생성하고 구성(Configuration)하는 영역으로 분리  
할인 정책을 변경해도 AppConfig가 있는 구성 영역만 변경하면 됨. 물론 클라이언트 코드인 주문 서비스 코드도  
변경하지 않음.  
  
# IoC, DI, 그리고 컨테이너
## 제어의 역전 IoC(Inversion of Control)
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.  
  
AppConfig가 등장한 이후에 프로그램의 제어 흐름은 AppConfig가 가젼간다.  
예를 들어 `OrderServiceImpl`은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될지 모른다.  
  
## 프레임워크 vs 라이브러리
프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다.(JUnit)  
반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.  
  
## 의존관계 주입 DI(Dependency Injection)  
`OrderServiceImpl`은 `DiscountPolicy` 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.  
의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을  
분리해서 생각해야 한다.  
  
[정적인 클래스 의존관계]  
클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다.  
정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.  
OrderServiceImpl은 MemberRepository, DiscountPolicy에 의존한다는 것을 알 수 있다.  
그런데 이러한 클래스 의존관계 만으로는 실제 어떤 객체가 OrderServiceImpl에 주입 될지 알 수 없다.  
  
[동적인 객체 인스턴스 의존 관계]  
애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계이다.  

애플리케이션 실행 시점(런타임)에 외부에서(AppConfig) 실제 구현 객체를 생성하고 클라이언트에 전달해서  
클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라 한다.  
객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.  
의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를  
쉽게 변경할 수 있다.  
  
## IoC 컨테이너, DI 컨테이너 = IoC를 해주는 컨테이너, DI를 해주는 컨테이너  
객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라 한다.  
  
설정을 구성한다는 뜻의 @Configuration을 붙여준다.  
각 메서드에 @Bean을 붙여주면 스프링 컨테이너에 스프링 빈으로 등록한다.  
  
# 스프링 컨테이너
ApplicationContext : 스프링 컨테이너라 한다.  
기존에는 개발자가 AppConfig를 사용해서 직접 객체 생성하고 DI를 했지만, 이제부터는 스프링 컨테이너를 통해 사용한다.  
  
스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정(구성) 정보로 활용한다.  
여기서 @Bean 이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.  
이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.  
  
스프링 빈은 @Bean이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다.  
  
스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다. 스프링 빈은 applicationContext.getBean()  
메서드를 사용해서 찾을 수 있다.  
  
기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.  
  
# 스프링 컨테이너와 스프링 빈
