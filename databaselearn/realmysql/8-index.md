# 인덱스
인덱스에 대한 기본 지식은 개발자나 관리자에게 매우 중요한 부분이며, 쿼리 튜닝의 기본이 될 것이다.  
# 1. 디스크 읽기 방식
"랜덤(Random) I/O", "순차(Sequential) I/O"와 같은 디스크 읽기 방식을 먼저 간단히 알아보겠다.  
  
최근에는 자기 디스크 원판에 의존하는 하드 디스크보다 SSD 디스크가 많이 활용되고 있지만, 여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이라는 사실에는 변함이 없다.  
데이터베이스의 성능 튜닝은 어떻게 **디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.**  
  
## 1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
컴퓨터에서 CPU나 메모리 같은 주요 장치는 대부분 전자식 장치지만 하드 디스크 드라이브는 기계식 장치다. 그래서 데이터베이스 서버에서는 항상 디스크 장치가 병목이 된다.  
이러한 기계식 하드 디스크 드라이브를 대체하기 위해 전자식 저장 매체인 SSD(Solid State Drive)가 많이 출시되고 있다.  
SSD도 기존 하드 디스크 드라이브와 같은 인터페이스(SATA나 SAS)를 지원하므로 내장 디스크나 DAS 또는 SAN에 그대로 사용할 수 있다.  
  
SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)을 제거하고 그 대신 플래시 메모리를 장착하고 있다.  
플래시 메모리  
- 디스크 원판을 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다.  
- 전원이 공급되지 않아도 데이터가 삭제되지 않는다.  
- 컴퓨터의 메모리(D-Ram)보다는 느리지만 기계식 하드 디스크 드라이브보다는 훨씬 빠르다.  
  
DRAM과 SSD의 차이는 1000배 정도. 요즘은 DBMS 용으로 사용할 서버에는 대부분 SSD를 채택하고 있다.  
  
디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 하드 디스크 드라이브보다 조금 빠르거나 거의 비슷한 성능을 보이기도 한다. 하지만 SSD의 장점은 기존 하드 디스크 드라이브보다 랜덤 I/O가 훨씬 빠르다는 것이다. 데이터베이스 서버에서 **순차 I/O 작업은 그다지 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분**이므로 SSD의 장점은 DBMS용 스토리지에 최적이라고 볼 수 있다. 일반적인 웹 서비스(OLTP: OnLine Transaction Processing) 환경의 데이터베이스에서는 SSD가 하드 디스크 드라이브보다는 훨씬 빠르다.  
  
## 1.2 랜덤 I/O와 순차 I/O
랜덤 I/O 라는 표현은 하드 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미하는데, 사실, 순차 I/O 또한 이 작업 과정은 같다. 그렇다면 랜덤 I/O와 순차 I/O는 어떤 차이가 있을까?  
  
순차 I/O는 3개의 페이지(3 * 16KB)를 디스크에 기록하기 위해 1번 시스템 콜을 요청했지만, 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번 시스템 콜을 요청했다.  
즉, 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직였고, 랜덤 I/O는 디스크 헤드를 3번 움직였다.  
**디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.** 결국 순차 I/O는 랜덤 I/O보다 거의 3배정도 빠르다고 볼 수 있다. 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다고 볼 수 있다. 그래서 여러 번 쓰기 또는 읽기를 요청하는 랜덤 I/O 작업이 작업 부하가 훨씬 더 크다. 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.  
  
디스크 원판을 가지지 않는 SSD는 랜덤 I/O와 순차 I/O의 차이가 없을 것으로 예측하지만, 실제로는 그렇지 않다. SSD 드라이브에서도 랜덤 I/O는 여전히 순차 I/O보다 전체 스루풋(Throughput)이 떨어진다.  
```
Throughput: 단위 시간당 처리되는 작업의 수나 데이터 전송량
```
사실 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다. **일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.**  
**여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.**  
  
- 인덱스 레인지 스캔: 주로 랜덤 I/O 사용  
- 풀 테이블 스캔: 순차 I/O 사용  
그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.  
이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문인데, 이런 형태는 OLTP(On-Line Transaction Processing) 성격의 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다.  
  
랜덤 I/O나 순차 I/O 모두 파일에 쓰기를 실행하면 반드시 동기화(fsync 또는 flush)가 필요하다. 그런데 순차 I/O인 경우에도 이러한 파일 동기하 작업이 빈번히 발생한다면 랜덤 I/O와 같이 비효율적인 형태로 처리될 때가 많다. 기업용으로 사용하는 데이터베이스 서버에는 캐시 메모리가 장착된 RAID 컨트롤러가 일반적으로 사용되는데, RAID 컨트롤러의 캐시 메모리는 아주 빈번한 파일 동기화 작업이 호출되는 순차 I/O를 효율적으로 처리될 수 있게 변환하는 역할을 한다. 하드 디스크뿐만 아니라 SSD를 사용하는 경우에도 RAID 컨트롤러는 중요한 역할을 한다.  
# 2. 인덱스란?
책의 마지막 "찾아보기" - 인덱스  
책의 내용 - 데이터 파일  
책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유될 것이다.  
  
**[칼럼(또는 칼럼들)의 값]과 [해당 레코드가 저장된 주소]를 키와 값의 쌍(key-Value pair)으로 삼아 인덱스 만든다.**  
DBMS의 인덱스는 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.  
  
SortedList는 DBMS의 인덱스와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다.  
DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 **항상 정렬된 상태를 유지한다.** 데이터 파일은 저장된 순서대로 별도의 정렬 없이 그대로 저장해 둔다.  
  
DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 `INSERT나 UPDATE, DELETE` 문장의 처리가 느려진다. 하지만 이미 정렬된 "찾아보기"용 표(인덱스)를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리할 수 있다.  
결론적으로 DBMS는 `INSERT나 UPDATE, DELETE` 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.  
테이블의 인덱스를 하나 더 추가할지 말지  
- 데이터의 저장 속도를 어디까지 희생할 수 있는지  
- 읽기 속도를 얼마나 더 빠르게 만들어야 하는지  
  
에 따라 결정해야 한다. SELECT 쿼리 문장의 WHERE 조건절에 사용하는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.  
  
이 책에서는 키(Key)라는 말고 인덱스(Index)는 같은 의미로 사용하겠다.  
인덱스를 역할별로 구분해 본다면 프라이머리 키(Primary key)와 보조 키(세컨더리 인덱스, Secondary key)로 구분할 수 있다.  
  
대표적으로는 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.  
**B-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.** 위치 기반 검색을 지원하기 위한 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있다.  
**Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.** 하지만 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 경우 해시 인덱스를 사용할 수 없다. Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.  
  
유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다. 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.  
인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.  
유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.  
  
# 3.B-Tree 인덱스 (Balanced Tree)
**B-Tree는 칼럼의 원래 값을 변형시키지 않고 (물론 값의 앞부분만 잘라서 관리하기는 하지만) 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.**  
전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘이다.  
  
## 3.1 구조 및 특성
B-Tree는 트리 구조의 최상위에 하나의 "루트 노드(Root node)"가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다. 트리 구조의 가장 하위에 있는 노드를 "리프 노드(Leaf node)"라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 "브랜치 노드(Branch node)" 라고 한다.  
데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.  
  
인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다. 많은 사람들이 데이터 파일의 레코드는 INSERT 된 순서대로 저장되는 것으로 생각하지만 그렇지 않다. 만약 테이블의 레코드를 전혀 삭제하거나 변경하지 않고 INSERT만 수행한다면 맞을 수도 있다. 하지만 레코드가 삭제되어 빈 공간이 생기면 그다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에 항상 INSERT된 순서로 저장되는 것은 아니다.  
  
```
대부분의 RDBMS - 임의의 순서로 저장
InnoDB - 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장
InnoDB에서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이블이 생성된다.
클러스터링이란 비슷한 값을 최대한 모아서 저장하는 방식을 의미한다.
```
InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다. 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다. 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.  
## 3.2 B-Tree 인덱스 키 추가 및 삭제
**테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다.**  
### 인덱스 키 추가
새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.  
B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 `B-Tree의 리프 노드`에 저장한다.  
리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리(Split)돼야 하는데, 이는 상위 브랜치 노드까지 처리 범위가 넓어진다. 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.  
  
테이블에 레코드를 추가하는 작업 비용을 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5 정도로 예측하는 것  
테이블에 인덱스가 하나도 없다면 작업 비용이 1이고, 3개인 경우에는 5.5 정도의 비용(1.5 * 3 + 1) 정도로 예측한다.  
중요한 것은 이 비용의 대부분이 메모리와 CPU에서 처리하는 시간이 아니라 **디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간**이라는 점이다.  
  
MyISAM, MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.  
InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다. 하지만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.  
```
[체인지 버퍼]
RDBMS에서 레코드가 INSERT되거나 UPDATE될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.
그런데 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다.
그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면
이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데, 이때 사용하는 임시 메모리 공간을 체인지 버퍼(Change buffer)라고 한다.
```
### 인덱스 키 삭제
해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다. 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용할 수 있다.  
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기(디스크 I/O)가 필요하다. MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연 처리될 수도 있다. MyISAM이나 MEMORY 스토리지 엔진의 테이블에서는 체인지 버퍼와 같은 기능이 없으므로 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.  
### 인덱스 키 변경
**인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로** B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다.  
B-Tree 상의 키 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다. InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리될 수 있다.  
### 인덱스 키 검색
인덱스를 검색하는 작업은 B-Tree의 루트 노드 -> 브랜치 노드 -> 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 "트리 탐색"이라고 한다.  
인덱스 트리 탐색은 SELECT 에서만 사용하는 것이 아니라 UPDATE 나 DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용할 수 있다. 부등호("<, >") 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다. **또한 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다.**  
이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니다. 따라서 함수나 연산을 수행한 결과로 정렬하거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의해야 한다.  
  
InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다. InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.  
따라서 UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 인덱스를 잠근다. 심지어 테이블의 모든 레코드를 잠글 수도 있다.  

## 3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
`인덱스를 구성하는 칼럼의 크기`와 `레코드의 건수`, 그리고 `유니크한 인덱스 키 값의 개수` 등에 듸해 검색이나 변경 작업의 성능이 영향을 받는다.  
### 인덱스 키 값의 크기
**InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) 또는 블록(Block)** 이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.  
또한 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. 인덱스도 결국은 페이지 단위로 관리되며, 루트와 브랜치, 리프 노드를 구분한 기준이 바로 페이지 단위다.  

일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. 자식 노드를 몇 개 까지 가지는지 궁금할 것이다. 그것은 바로 `인덱스의 페이지 크기와 키 값의 크기`에 따라 결정된다.  
MySQL 5.7버전부터는 InnoDB 스토리지 엔진의 페이지 크기를 innodb_page_size 시스템 변수를 이용해 4KB ~ 64KB 사이의 값을 선택할 수 있지만 기본값은 16KB다.  
    
인덱스의 키가 16바이트라고 가정하자. 자식 노드 주소는 여러 가지 복합적인 정보가 담긴 영역이며, 대략 6 ~ 12바이트까지 다양한 크기의 값을 가질 수 있다. 여기서는 12바이트로 가정하자.  
하나의 인덱스 페이지(16KB)에 16*1024 / (16+12) = 585개 저장할 수 있다. 최종적으로 이 경우는 자식 노드를 585개 가질 수 있는 B-Tree가 되는 것이다. 인덱스 키를 32바이트로 늘어났다고 가정하면 16 * 1024 / (32 + 12) = 372개 저장할 수 있다. 여러분의 SELECT 쿼리가 레코드 500개를 읽어야 한다면 전자는 인덱스 페이지 한번으로 해결될 수도 있지만, 후자는 최소한 2번 이상 디스크로부터 읽어야 한다.  
  
결국 인덱스를 구성하는 인덱스 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.  
또한 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미한다. 하지만 인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 **메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다.** 그렇게 되면 자연히 메모리의 효율이 떨어지는 결과를 가져온다.  
### B-Tree 깊이
B-Tree 인덱스의 깊이는 상당히 중요하지만 직접 제어할 방법은 없다. 여기서는 인덱스 키 값의 평균 크기가 늘어나면 어떤 현상이 추가로 더 발생하는지 알아보겠다.  
B-Tree의 깊이가 3인 경우 키 값이 16바이트일 때 최대 2억(585 * 585 * 585)개 정도의 키 값을 담을 수 있지만, 32바이트일 때 5천만 개로 줄어든다.  
  
B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다. 결론적으로 인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미한다.  

인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다. 실제로는 아무리 대용량의 데이터베이스라도 B-Tree의 깊이가 5단계 이상까지 깊어지는 경우는 흔치 않다.  
### 선택도(기수성)
인덱스에서 선택도(Selectivity) 또는 기수성(Cardinality)은 거의 같은 의미로 사용되며, 모든 인덱스의 키 값 가운데 유니크한 값의 수를 의미한다.  
인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다. **인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.**  
  
```SQL
CREATE TABLE tb_city(
  country VARCHAR(10),
  city VARCHAR(10),
  INDEX ix_country (country)
);
```
tb_city 테이블은 1만 건의 레코드를 가지고 있다. tb_city 테이블에는 국가와 도시가 중복해서 저장돼 있지 않다고 가정하자.  
```SQL
SELECT *
FROM tb_test
WHERE country='KOREA' AND city='SEOUL';
```
**[country 유니크 칼럼의 값이 10개일 때]**  
전체 레코드 수를 유니크한 값의 개수로 나눠보면 하나의 키 값으로 검색했을 때 대략 몇 건의 레코드가 일치할지 예측할 수 있게 된다. 이 케이스의 tb_city 테이블에서는 1000건(10,000/10)이 일치하리라는 것을 예상할 수 있다. 그런데 인덱스를 통해 검색된 1000건 가운데 city='SEOUL' 인 레코드는 1건이므로 999건은 불필요하게 읽은 것으로 볼 수 있다.  

**[country 유니크 칼럼의 값이 1000개일 때]**  
이 케이스의 tb_city 테이블에서는 10건(10,000/1000)이 일치하리라는 것을 예상할 수 있다. 그 10건 중에서 city='SEOUL'인 레코드는 1건이므로 9건을 불필요하게 읽은 것이다.  
인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.  
### 읽어야 하는 레코드의 건수
**인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.**    
일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.  
  
즉, 인덱스를 통해 읽어야 할 레코드의 건수(물론 옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다. 전체 100만 건의 레코드 가운데 50만 건을 읽어야 하는 작업은 인덱스의 손익 분기점인 20~25%보다 훨씬 크기 때문에 MySQL 옵티마이저는 인덱스를 이용하지 않고 직접 테이블을 처음부터 끝까지 읽어서 처리할 것이다. 이렇게 많은 레코드(전체 레코드의 20 ~25% 이상)를 읽을 때는 강제로 인덱스를 사용하도록 힌트를 추가해도 성능상 얻을 수 있는 이점이 없다.  
## 3.4 B-Tree 인덱스를 통한 데이터 읽기
### 인덱스 레인지 스캔
```SQL
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 필요한 레코드의 시작 지점을 찾을 수 있다. 일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다. 이처럼 차례대로 쭉 읽는 것을 스캔이라고 표현한다. 만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다. 그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.  
  
B-Tree의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많은데, 이 과정을 좀 더 자세히 살펴보자.  
  
어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다. 이는 별도의 정렬 과정이 수반되는 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다.**인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.** 이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다. 3건의 레코드가 검색 조건에 일치했다고 가정하면, 데이터 레코드를 읽기 위해 랜덤 I/O가 최대 3번 필요한 것이다. 그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다. 그리고 인덱스를 통해 읽어야 할 데이터 레코드가 20 ~ 25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다.  
  
1. 인덱스에서 조건이 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색(Index seek)이라고 한다.  
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔(Index scan)이라고 한다.  
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.  
  
쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수도 있는데, 이를 커버링 인덱스라고 한다. 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다.  
```SQL
SHOW STATUS LIKE 'Handler_%'
```
Handler_read_key 상태 값은 1번 단계가 실행된 횟수, Handler_read_next와 Handler_read_prev는 2번 단계로 읽은 레코드 건수를 의미한다.(정순, 역순)  
Handler_read_first와 Hander_read_last는 인덱스의 첫 번째 레코드와 마지막 레코드를 읽은 횟수를 의미하는데, 이 둘은 MIN() 또는 MAX()와 같이 제일 큰 값 또는 제일 작은 값만 읽는 경우 증가하는 상태 값이다. 이 상태 값들은 읽은 레코드 건수를 의미하는데, 실제 인덱스만 읽었는지 인덱스를 통해 테이블의 레코드를 읽었는지(3번 단계)는 구분하지 않는다.  
### 인덱스 풀 스캔
**인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다.**  
대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다. 예를 들어 인덱스는 (A, B, C) 칼럼의 순서로 만들어져 있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우다.  
  
일반적으로, 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스만 읽는 것이 효율적이다. 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다. 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않는다.  
  
먼저 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔하는 방식을 인덱스 풀 스캔이라고 한다.  
이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. 인덱스에 포함된 칼럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문이다. 인덱스의 전체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 인덱스 풀 스캔은 테이블 전체를 읽는 것보다는 적은 디스크 I/O로 쿼리를 처리할 수 있따.  
### 루스 인덱스 스캔
오라클의 "인덱스 스킵 스캔"이라고 하는 기능과 작동 방식은 비슷하다. 앞의 인덱스 레인지, 풀 스캔은 루스 인덱스 스캔과는 상봔된 의미에서 타이트 인덱스 스캔으로 분류한다.  
  
**루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.**  
루스 인덱스 스캔은 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다. 일반적으로 `GROUP BY` 또는 집합 함수 가은데 `MAX()` 또는 `MIN()` 함수에 대해 최적화를 하는 경우에 사용된다.  
```SQL
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```
이 쿼리에서 사용된 dept_emp 테이블은 dept_no와 emp_no라는 두 개의 칼럼으로 인덱스가 생성돼 있다. 또한 이 인덱스는 (dept_no, emp_no) 조합으로 정렬까지 돼 있어서 dept_no 그룹별로 첫 번째 레코드의 emp_no 값만 읽으면 된다. 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다.  
### 인덱스 스킵 스캔
데이터베이스 서버에서 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다. 다음과 같은 인덱스를 생성해보자.  
```SQL
ALTER TABLE employees
  ADD INDEX ix_gender_birthdate (gender, birth_date);
```
이 인덱스를 사용하려면 WHERE 조건절에 gender 칼럼에 대한 비교 조건이 필수다.  
```SQL
-- // 인덱스를 사용하지 못하는 쿼리
SELECT * FROM employees WHERE birth_date>='1965-02-01';

-- // 인덱스를 사용할 수 있는 쿼리
SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
```
주로 이런 경우에는 birth_date 칼럼부터 시작하는 인덱스를 새로 생성해야만 했다.  
MySQL 8.0 버전부터는 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 칼럼만으로 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔(Index skip scan) 최적화 기능이 도입됐다.  
이전의 루스 인덱스 스캔은 GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용할 수 있었다. 하지만 MySQL 8.0 버전에 도입된 인덱스 스킵 스캔은 WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 훨씬 넓어진 것이다.  
  
인덱스 스킵 스캔 기능을 비활성화하고, MySQL 8.0 이전 버전에서 어떤 실행 계획으로 처리됐는지를 한 번 살펴보자.  
```SQL
SET optimizer_switch='skip_scan=off';

EXPLAIN
SELECT gender, birth_date
FROM employees
WHERE birth_date>='1965-02-01';
```
위의 쿼리는 WHERE 조건절에 gender 칼럼에 대한 조건 없이 birth_date 칼럼의 비교 조건만 가지고 있기 때문에 ix_gender_birthdate 를 효율적으로 이용할 수 없다. type 칼럼이 "index"라고 표시된 것은 인덱스를 처음부터 끝까지 모두 읽었다(풀 인덱스 스캔)는 의미이므로 인덱스를 비효율적으로 사용한 것이다. 이 예제 쿼리는 인덱스에 있는 gender 칼럼과 birth_date 칼럼만 있으면 처리를 완료할 수 있기 때문에 ix_gender_birthdate 인덱스를 풀 스캔한 것이다. 만약 예제 쿼리가 employees 테이블의 모든 칼럼을 가져와야 했다면 테이블 풀 스캔을 실행했을 것이다.  
  
```SQL
SET optimizer_switch='skip_scan=on';

EXPLAIN
SELECT gender, birth_date
FROM employees
WHERE birth_date>='1965-02-01';
```
인덱스 싑 스캔을 활성화하고 실행 계획을 살펴보면 type 칼럼의 값이 range로 표시됐는데, 이는 인덱스에서 꼭 필요한 부분만 읽었다는 것을 의미한다.  
Extra 칼럼에 Using index for skip scan이라는 문구가 표시됐는데, 이는 ix_gender_birthdate 인덱스에 대해 인덱스 스킵 스캔을 활용해 데이터를 조회했다는 것을 의미한다.  
  
MySQL 옵티마이저는 우선 gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다.  
```SQL
SELECT gender, birth_date
FROM employees
WHERE gender='M' AND birth_date>='1965-02-01';

SELECT gender, birth_date
FROM employees
WHERE gender='M' AND birth_date>='1965-02-01';
```
gender 칼럼에 대해 가능한 값 2개(M, F)를 구한 다음, 옵티마이저는 내부적으로 아래 2개의 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행하게 된다.  
```
칼럼이 어떤 타입이라도 MySQL 서버는 인덱스를 루스 인덱스 스캔(중간에 필요치 않은 인덱스 키 값은 무시)과 동일한 방식으로 읽으면서
인덱스에 존재하는 모든 값을 먼저 추출하고 그 결과를 이용해 인덱스 스킵 스캔을 실행한다.
```
다음과 같은 단점이 있다.  
- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함  
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)  
  
만약 유니크한 값의 개수가 매우 많다면 MySQL 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다. 그래서 쿼리의 처리 성능이 오히려 더 느려질 수도 있다.  
두 번째 제약 조건은 다음 쿼리를 통해 알 수 있는데, 이 쿼리는 ix_gender_birthdate 인덱스에 포함된 gender 칼럼과 birth_date 칼럼 이외의 나머지 칼럼도 필요로 하기 때문에 인덱스 스킵 스캔을 사용하지 못하고 풀 테이블 스캔으로 실행 계획을 수립한 것으로 확인할 수 있다.  
```SQL
EXPLAIN
SELECT *
FROM employees
WHERE birth_date>='1965-02-01';
```
## 3.5 다중 칼럼(Multi-column) 인덱스
두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스(또는 복합 칼럼 인덱스)라고 하며, "Concatenated Index"라고도 한다.  
데이터 레코드 건수가 작은 경우에는 루트 노드와 리프 노드만 있을 수도 있다.  
  
두 번째 칼럼의 정렬은 첫 번째 칼럼에 의존해서 정렬돼 있다. 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에 의존, 네 번쨰 칼럼은 세 번째 칼럼에 의존해서 정렬된다.  
다중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하다.  
## 3.6 B-Tree 인덱스의 정렬 및 스캔 방향
인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장된다. 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.  
  
### 인덱스의 정렬
MySQL 8.0 버전부터는 다음과 같은 형태의 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다.  
```SQL
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```
### 인덱스 스캔 방향
first_name 칼럼에 대한 인덱스가 포함된 employees 테이블에 대한 다음 쿼리를 실행하는 과정을 한 번 살펴보자.  
```SQL
SELECT *
FROM employees
ORDER BY first_name DESC
LIMIT 1;
```
인덱스는 오름차순으로만 정렬돼 있지만 인덱스를 최댓값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 이미 알고 있다. 위의 쿼리는 인덱스를 역순으로 접근해 첫 번쨰 레코드만 읽으면 된다. 즉, 인덱스 생성 시점에 오름차순 또는 내림차순 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.  
```SQL
SELECT * FROM employees WHERE first_name>='Anneke'
ORDRE BY first_name ASC LIMIT 4;

SELECT * FROM employees
ORDER BY first_name DESC LIMIT 5;
```
위의 첫 번째 쿼리는 first_name 칼럼에 정의된 인덱스를 이용해 "Anneke"라는 레코드를 찾은 후, 정순으로 해당 인덱스를 읽으면서 4개의 레코드만 가져오면 아무런 비용을 들이지 않고도 원하는 정렬 효과를 얻을 수 있다. 두 번째 쿼리는 이와 반대로 employees 테이블에 first_name 칼럼에 정의된 인덱스를 역순으로 읽으면서 처음 다섯 개의 레코드만 가져오면 된다.  
쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 최적화가 필요한 경우에도 MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.  
  
### 내림차순 인덱스
다음 두 쿼리는 실제 내림차순인지 오름차순인지와 관계없이 `인덱스를 읽는 순서만 변경`해서 해결할 수 있다.  
```SQL
SELECT * FROM employees ORDER BY first_name ASC LIMIT 10;
SELECT * FROM employees ORDER BY first_name DESC LIMIT 10;
```
물론 다음과 같이 2개 이상의 칼럼으로 구성된 복합 인덱스에서 각각의 칼럼이 내림차순과 오름차순이 혼합된 경우에는 MySQL8.0의 내림차순 인덱스로만 해결될 수 있다.  
물론 2개 이상의 칼럼이 내림차순 그리고 오름차순을 동시에 사용하는 쿼리를 위해서는, 각 칼럼이 오름차순 그리고 내림차순으로 정의된 복합 칼럼 인덱스가 필요하다.   
```SQL
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```
first_name 칼럼을 역순으로 정렬하는 요건만 있다면 다음 2개 인덱스 중에서 어떤 것을 선택하는 것이 좋을까?  
```SQL
CREATE INDEX ix_firstname_asc ON employees (fisrt_name ASC);
CREATE INDEX ix_firstname_asc ON employees (fisrt_name DESC);
```

테이블을 풀 스캔하면서 정렬만 수행하는 쿼리를 다음과 같이 한번 실행해보자.  
다음 두 쿼리는 테이블의 프라이머리 키를 정순 또는 역순으로 스캔하면서 마지막 레코드 1건만 반환한다.  
첫 번째 쿼리는 tid 칼럼의 값이 가장 큰 레코드 1건을, 그리고 두 번째 쿼리는 tid 칼럼의 값이 가장 작은 레코드 1건을 반환한다. LIMIT ... OFFSET 부분의 쿼리로 인해 실제 MySQL 서버는 테이블의 모든 레코드를 스캔해야 한다.  
```SQL
SELECT * FROM t1 ORDER BY tid ASC LIMIT 12619775, 1; // 4.15 sec

SELECT * FROM t1 ORDER BY tid DESC LIMIT 12619775, 1; // 5.35 sec
```
역순 정렬 쿼리가 정순 정렬 쿼리보다 28.9% 시간이 더 걸리는 것을 확인할 수 있다. 실제 내부적으로는 `인덱스 역순 스캔이`, `인덱스 정순 스캔`에 비해 느릴 수밖에 없는 다음의 두 가지 이유가 있다.  
- 페이지 잠금이 인덱스 정순 스캔(Forward index scan)에 적합한 구조  
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조  
  
일반적으로 인덱스를 ORDER BY ... DESC 하는 쿼리가 소량의 레코드에 드물게 실행되는 경우라면 내림차순 인덱스를 굳이 고려할 필요는 없어 보인다.  
```SQL
SELECT * FROM tab
WHERE userid=?
ORDER BY score DESC
LIMIT 10;
```
이 쿼리의 경우 다음 두 가지 인덱스 모두 적절한 선택이 될 수 있다.  
```
오름차순 인덱스: INDEX (userid ASC, score ASC)
내림차순 인덱스: INDEX (userid DESC, score DESC)
```
하지만 위 쿼리가 많은 레코드를 조회하면서 빈번하게 실행된다면 내림차순 인덱스가 더 효율적이라고 볼 수 있다. 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 될 것이다.  
  
```
InnoDB 스토리지 엔진에서 데이터 파일은 프라이머리 키 인덱스 그 자체라는 것에 주의하자
```
## 3.7 B-Tree의 인덱스의 가용성과 효율성
쿼리의 WHERE 조건이나 GROUP BY, ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.  
여기서는 어떤 조건에서 인덱스를 사용할 수 있고 어떨 때 사용할 수 없는지 살펴보겠다. 또한 인덱스를 100% 활용할 수 있는지, 일부만 이용하게 되는지도 함께 살펴보겠다.  
  
### 비교 조건의 종류와 효율성
다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교("=") 인지 아니면 크다 또는 작다(">", "<") 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다. 다음 예제를 한번 살펴보자.  
```SQL
SELECT * FROM dept_mep 
  WHERE dept_no='d002' AND emp_no >=10114;
```
이 쿼리를 위해 다른 두 가지 케이스로 인덱스를 생성했다고 가정하자.  
- 케이스 A: INDEX (dept_no, emp_no)  
- 케이스 B: INDEX (emp_no, dept_no)  
  
케이스 A 인덱스는 dept_no='d002' AND emp_no >=10114 인 레코드를 찾고, 그 이후에는 dept_no가 'd002'가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 된다. 이 경우 읽은 레코드가 모두 사용자가 원하는 결과임을 알 수 있다. 케이스 B는 우선 emp_no >=10114 AND dept_no='d002'인 레코드를 찾고, 그 이후 모든 레코드에 대해 dept_no가 'd002'인지 비교하는 과정을 거쳐야 한다.  
  
**이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 '필터링'이라고도 한다.** 케이스 B 인덱스에서는 최종적으로 dept_no='d002' 조건을 만족(필터링)하는 레코드 5건을 가져온다. 즉, 이 경우에는 5건의 레코드를 찾기 위해 7번의 비교 과정을 거친 것이다. 그 이유는 다중 칼럼 인덱스에서 설명한 다중 칼럼 인덱스의 정렬 방식 때문이다.  
(인덱스의 N번째 키 값은 N-1 번째 키 값에 대해서 다시 정렬됨).  
  
작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 (필터링 조건)체크 조건은 많다고 해서 (최종적으로 가져오는 레코드는 작게 만들지 몰라도) 쿼리의 처리 성능을 높이지는 못한다.  
오히려 쿼리 실행을 더 느리게 만들 때가 많다.  
### 인덱스의 가용성
B-Tree 인덱스의 특징은 왼쪽 값에 가준해서(Left-Most) 오른쪽 값이 정렬돼 있다는 것이다. (하나의 칼럼 내에서뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 함께 적용된다.)  
- 케이스 A: INDEX (first_name)  
- 케이스 B: INDEX (dept_no, emp_no)  
  
하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색이 불가능하다. 또한 다중 칼럼 인덱스에서도 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.  
```SQL
SELECT * FROM employees WHERE first_name LIKE '%mer';
```
이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수는 없다. 그 이유는 fisrt_name 칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상숫값('%mer')에는 왼쪽 부분이 고정되지 않았기 때문이다. 따라서 정렬 우선순위가 낮은 뒷부분의 값만으로는 왼쪽 기준(Left-most) 정렬 기반의 인덱스인 B-tree에서는 인덱스의 효과를 얻을 수 없다.  
  
```SQL
SELECT * FROM dept_emp WHERE emp_no >= 10144;
```
인덱스가 (dept_no, emp_no) 칼럼 순서대로 생성돼 있다면 인덱스의 선행 칼럼인 dept_no 조건 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다. 케이스 B의 인덱스는 다중 칼럼으로 구성된 인덱스이므로 dept_no 칼럼에 대해 먼저 정렬한 후, 다시 emp_no 칼럼값으로 정렬돼 있기 때문이다. 왼쪽 값 기준 규칙은 GROUP BY 절이나 ORDER BY 절에도 똑같이 적용된다.  
### 가용성과 효율성 판단 
```
작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'이라고 하고, 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 '필터링 조건', '체크 조건' 이라고 표현한다.
```
기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다.(작업 범위 결정 조건으로 사용할 수 없다. 경우에 따라서 필터링(체크) 조건으로 인덱스를 사용할 수는 있다)  
  
1. NOT-EQUAL로 비교된 경우(<>, NOT IN, NOT BETWEEN, IS NOT NULL)  
2. LIKE '%??' 형태로 문자열 패턴이 비교된 경우  
3. 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우  
4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우  
5. 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)  
6. 문자열 데이터 타입의 콜레이션이 다른 경우  
  
일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스에 저장된다. 다음과 같은 WHERE 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.  
```SQL
WHERE column IS NULL ...
```
다중 칼럼 인덱스의 경우를 알아보자. 다음과 같은 인덱스가 있다고 가정해 보자.  
```SQL
INDEX ix_test ( column_1, column_2, column_3, ... , column_n )
```
**[작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우]**  
column_1 칼럼에 대한 조건이 없는 경우  
column_1 칼럼이 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 이유  
  
**[작업 범위 결정 조건으로 인덱스를 사용하는 경우]**  
column_1 ~ column_(i-1) 칼럼까지 동등 비교 형태("=" 또는 "IN")로 비교  
column_i 칼럼에 대해 다음 연산자 중 하나로 비교("=" 또는 "IN", ">", "<", LIKE 좌측 일치 패턴)  
  
위의 두 가지 조건을 모두 만족하는 쿼리는 column_1 부터 column_i까지는 작업 범위 결정 조건으로 사용되고, column_(i+1) 부터 column_n까지의 조건은 체크 조건으로 사용된다.  
```SQL
-- // 다음 쿼리는 인덱스를 사용할 수 없음
... WHERE column_1 <> 2

-- // 다음 쿼리는 column_1과 column_2 까지 범위 결정 조건으로 사용됨
... WHERE column_1 = 1 AND column_2 > 10

-- // 다음 쿼리는 column_1,column_2,column_3 까지 범위 결정 조건으로 사용됨
... WHERE column_1 IN (1, 2) AND column_2 =2 AND column_3 <= 10

-- // 다음 쿼리는  column_1,column_2,column_3 까지 범위 결정 조건으로, column_4는 체크 조건으로 사용됨
... WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10, 20, 30) AND column_4 <> 100
```
# 4. R-Tree 인덱스
MySQL의 공간 인덱스(Spatial Index)는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다. 기본적인 내부 매커니즘은 B-Tree와 흡사하다.  
B-Tree는 인덱스를 구성하는 칼럼의 값이 1차원의 스칼라 값인 반면, R-Tree 인덱스는 2차원의 공간 개념 값이라는 것이다.  
  
MySQL의 공간 확장(Spatial Extension)을 활용하면 위치 기반 서비스를 간단하게 구현할 수 있다.  MySQL의 공간 확장에는 다음과 같이 크게 세 가지 기능이 포함돼 있다.  
  
- 공간 데이터를 저장할 수 있는 데이터 타입  
- 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)  
- 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)  

## 4.1 구조 및 특성
MBR: Minimum Bounding Rectangle의 약자로 해당 도형을 감싸는 최소 크기의 사각형을 의미한다. **이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스다.**    
최상위 MBR은 R-Tree의 루트 노드에 저장되는 정보이며, 차상위 그룹 MBR은 R-Tree의 브랜치 노드가 된다. 마지막으로 각 도형의 개체는 리프 노드의 저장된다.  
## 4.2 R-Tree 인덱스의 용도  
일반적으로는 WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용된다.(좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용할 수 있다.)  
  
`ST_Contains()` 또는 `ST_Within()` 등과 같은 포함 관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스를 이용할 수 있다.  

# 6. 함수 기반 인덱스
일반적인 인덱스는 칼럼의 값 일부(칼럼의 값 앞부분) 또는 전체에 대해서만 인덱스 생성이 허용된다.  
**하지만 때로는 칼럼의 값을 변형해서 만들어진 값에 대해** 인덱스를 구축해야 할 때도 있는데, 이러한 경우 함수 기반의 인덱스를 활용하면 된다.  
MySQL 8.0 버전부터 함수 기반 인덱스를 지원하기 시작했는데, MySQL 서버에서 함수 기반 인덱스를 구현하는 방법은 다음과 같이 두 가지로 구분할 수 있다.  
- 가상 칼럼을 이용한 인덱스  
- 함수를 이용한 인덱스
  
함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이만 있을 뿐, 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree 인덱스와 동일하다.
## 6.1 가상 칼럼을 이용한 인덱스
```sql
CREATE TABLE user (
  user_id BIGINT,
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  PRIMARY_KEY (user_id)
);
```
그런데 first_name과 last_name을 합쳐서 검색해야 하는 요건이 생겼다면 이전 버전의 MySQL 서버에서는 full_name 이라는 칼럼을 추가하고 모든 레코드에 대해 full_name을 업데이트하는 작업을 거쳐야 했다. 그래야만 비로소 full_name 칼럼에 대한 인덱스를 생성할 수 있었다. 하지만 MySQL 8.0 버전부터는 다음과 같이 가상 칼럼을 추가하고 그 가상 칼럼에 인덱스를 생성할 수 있게 됐다.  
```sql
ALTER TABLE user
ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL , -- 가상 칼럼 추가
ADD INDEX ix_fullname(full_name); -- 가상 칼럼에 인덱스를 생성 
```
full_name 칼럼에 대한 검색도 ix_fullname 인덱스를 이용해 실행 계획이 만들어지는 것을 확인할 수 있다.  
```sql
EXPLAIN SELECT * FROM user WHERE user.full_name='euichan Hwang';
```
가상 칼럼이 VIRTUAL이나 STORED 옵션 중 어떤 옵션으로 생성됐든 관계없이 해당 가상 칼럼에 인덱스를 생성할 수 있다. 가상 칼럼은 테이블에 새로운 칼럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점이 있다.  
## 6.2 함수를 이용한 인덱스
가상 칼럼은 MySQL 5.7 버전에서도 사용할 수 있었지만 MySQL 5.7에서는 함수를 직접 인덱스 생성 구문에 사용할 수는 없었다.  
MySQL 8.0 버전부터는 다음과 같이 테이블의 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스를 생성할 수 있게 됐다.  
```java
CREATE TABLE user (
  user_id BIGINT,
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  PRIMARY_KEY (user_id),
  INDEX ix_fullname ((CONCAT(first_name,' ', last-name)))
)
```
함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만들어준다.  
함수 기반 인덱스를 제대로 활용하려면 **반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용되야 한다.**  
함수 생성 시 명시된 표현식과 쿼리의 WHERE 조건절에 사용된 표현식이 다르다면 (설령 결과는 같다고 하더라도) MySQL 옵티마이저는 다른 표현식으로 간주해서 함수 기반 인덱스를 사용하지 못한다.  
```sql
EXPLAIN SELECT * FROM user WHERE CONCAT(first_name,' ',last_name)='euichan Hwang';
```
만약 이 예제를 실행했을 때 옵티마이저가 표시하는 실행 계획이 ix_fullname 인덱스를 사용하지 않는 것으로 표시된다면 CONCAT 함수에 사용된 공백 문자 리터럴 때문일 가능성이 높다.  
이 경우 다음 3개 시스템 변수의 값을 동일 콜레이션(이 책에서는 "utf8mb4_0900_ai_ci")으로 일치시킨 후, 다시 테스트를 수행해보자.  
```
가상 칼럼(Virtual Column)을 이용한 방법과 직접 함수를 이용한 함수 기반 인덱스는 내부적으로 동일한 구현 방법을 사용한다.
결국 여기서 알아본 방법은 내부적인 구현이 동일한 것이라고 볼 수 있으며, 어떤 방법을 사용하더라도 둘의 성능 차이는 발생하지 않는다는 것을 의미한다.
```
# 7. 멀티 밸류 인덱스
전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가진다. 즉, 인덱스 키와 데이터 레코드는 1:1의 관계를 가진다. 하지만 멀티 밸류(Multi-Value) 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다. 일반적인 RDBMS를 기준으로 생각하면 이러한 인덱스는 정규화에 위배되는 형태다. 하지만 최근 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서 JSON 배열 타입의 필드에 저장된 원소(Element)들에 대한 인덱스 요건이 발생한 것이다.  
  
```sql
CREATE TABLE user (
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (user_id),
    credit_info JSON,
    INDEX my_creditscores ( (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)) )
);

INSERT INTO user VALUES (1, 'euichan', 'Hwang', '{"credit_scores":[360,353,351]}');
```
멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 안 되고, 반드시 다음 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.  
- MEMBER OF()  
- JSON_CONTAINS()  
- JSON_OVERLAPS()  
  
```sql
SELECT * FROM user WHERE 360 MEMBER OF(credit_info ->'$.credit_scores');
```
```
MySQL 8.0.21 버전에서는 CHAR/VARCHAR 타입에 대해서는 멀티 밸류 인덱스를 지원하지 않는다.
```
# 8. 클러스터링 인덱스
**클러스터링이란 여러 개를 하나로 묶는다**는 의미로 주로 사용되는데, 지금 설명하고자 하는 인덱스의 클러스터링도 그 의미를 크게 벗어나지 않는다.  
MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것이다.  
MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원하며, 나머지 스토리지 엔진에서는 지원되지 않는다.  
  
## 8.1 클러스터링 인덱스
클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다.  
**프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.**  
프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다. 또한 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미하기도 한다.  
  
일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 `프라이머리 키 기반의 검색`이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.  
```
일반적으로 B-Tree 인덱스도 인덱스 키 값으로 이미 정렬되어 저장된다. 이 또한 어떻게 보면 인덱스의 키 값으로 클러스터링된 것으로 생각할 수 있다.
하지만 이러한 일반적인 B-Tree 인덱스를 클러스터링 인덱스라고 부르지 않는다. 테이블의 레코드가 프라이머리 키 값으로 정렬되어 저장된 경우에만 "클러스터링 인덱스" 또는 "클러스터링 테이블"이라고 한다.
```
  
클러스터링 테이블의 구조를 살펴보면, 클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼이 같이 저장돼 있음을 알 수 있다.  
즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것이다.  
```sql
UPDATE tb_test SET emp_no=100002 WHERE emp_no=100007;
```
그림에서는 emp_no=100007인 레코드는 3번 페이지에 저장돼 있음을 확인할 수 있다. 하지만 emp_no가 100002로 변경되면서 2번 페이지로 이동한 것을 알 수 있다.  
```
MyISAM 테이블이나 기타 InnoDB를 제외한 테이블의 데이터 레코드는 프라이머리 키나 인덱스 키 값이 변경된다고 해서 실제 데이터 레코드의 위치가 변경되지는 않는다.
데이터 레코드가 INSERT될 때 데이터 파일의 끝(또는 임의의 빈 공간)에 저장된다. 이렇게 한번 결정된 위치는 절대 바뀌지 않고, 레코드가 저장된 주소는 MySQL 내부적으로 레코드를 식별하는 아이디로 인식된다. 레코드가 저장된 주소를 로우 아이디(ROW-ID)라고 표현하며, 일부 DBMS에서는 이 값을 사용자가 직접 조회하거나 쿼리의 조건으로 사용할 수 있다. 하지만 MySQL에서는 사용자에게 노출되지 않는다.
```
프라이머리 키가 없는 테이블은 InnoDB 스토리지 엔진이 다음 우선순위대로 프라이머리 키를 대체할 칼럼을 선택한다.  
1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택  
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터링 키로 선택  
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택  
  
적절한 클러스터링 키 후보를 찾지 못하는 경우 InnoDB 스토리지 엔진이 내부적으로 레코드의 일련번호 칼럼을 생성한다. 이렇게 자동으로 추가된 프라이머리 키(일련번호 칼럼)는 사용자에게 노출되지 않으며, 쿼리 문장에 명시적으로 사용할 수 없다. 즉, 아무 의미 없는 숫자 값으로 클러스터링되는 것이며, 이것은 우리에게 아무런 혜택을 주지 않는다. 가능하면 명시적으로 생성하자.  
  
## 8.2 세컨더리 인덱스에 미치는 영향
MyISAM이나 MEMORY 테이블 같은 클러스터링되지 않은 테이블은 INSERT 될 때 처음 저장된 공간에서 절대 이동하지 않는다. 데이터 레코드가 저장된 주소는 내부적인 레코드 아이디(ROWID) 역할을 한다고 언급한 바 있다. 그리고 프라이머리 키나 세컨더리 인덱스의 각 키는 그 주소(ROWID)를 이용해 실제 데이터 레코드를 찾아온다. 그래서 MyISAM 테이블이나 MEMORY 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.  
  
InnoDB에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가진다면 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다. 이런 오버헤드를 제거하기 위해 **InnoDB 테이블(클러스터링 테이블)의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현돼 있다.**  
  
employees 테이블에서 first_name 칼럼으로 검색하는 경우 프라이머리 키로 클러스터링된 InnoDB와 그렇지 않은 MyISAM에서 어떤 차이가 있는지 한번 살펴보자.  
```sql
CREATE TABLE employees (
  emp_no INT NOT NULL,
  first_name VARCHAR(20) NOT NULL,
  PRIMARY KEY (emp_no),
  INDEX ix_firstname (firstname)
);

SELECT * FROM employees WHERE first_name='Aamer';
```
MyISAM: ix_firstname 인덱스를 검색해서 레코드의 주소를 확인한 후, 레코드의 주소를 이용해 최종 레코드를 가져옴  
InnoDB: ix_firstname 인덱스를 검색해서 레코드의 프라이머리 키 값을 확인한 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴  
## 8.3 클러스터링 인덱스의 장점과 단점
MyISAM 과 같은 클러스터링되지 않은 일반 프라이머리 키와 클러스터링 인덱스를 비교했을 때의 상대적인 장단점을 정리해 보자.  
**장점**  
- 프라이머리 키(클러스터링 키)로 검색할 때 처리 성능이 매우 빠름(특히, 프라이머리 키를 범위 검색하는 경우 매우 빠름)  
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)  
  
**단점**  
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐  
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림  
- INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림  
- 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림  
  
대부분 클러스터링 인덱스의 장점은 빠른 읽기(SELECT)이며, 단점은 느린 쓰기(INSERT, UPDATE, DELETE)라는 것을 알 수 있다.  
일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경(OLTP)에서는 쓰기와 읽기의 비율이 2:8 또는 1:9 정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것은 매우 중요하다.  
  
## 8.4 클러스터링 테이블 사용 시 주의사항 
### 클러스터링 인덱스 키의 크기
클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키) 값을 포함한다. 그래서 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다. 하지만 테이블에 세컨더리 인덱스가 4~5개정도 생성된다는 것을 고려하면 세컨더리 인덱스 크기는 급격히 증가한다.  
  
### 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성(가능한 경우)
프라이머리 키로 검색하는 경우(특히 범위로 많은 레코드를 검색하는 경우) 클러스터링 되지 않은 테이블에 비해 매우 빠르게 처리될 수 있다. 프라이머리 키는 대부분 검색에서 상당히 빈번하게 사용되는 것이 일반적이다.  
  
### 프라이머리 키는 반드시 명시할 것
가능하면 AUTO_INCREMENT 칼럼을 이용해서라도 프라이머리 키는 생성하는 것을 권장한다.  
InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 InnoDB 스토리지 엔진이 내부적으로 일련번호 칼럼을 추가한다. 자동 추가된 칼럼은 사용자에게 보이지 않기 때문에 사용자가 전혀 접근(사용)할 수 없다.  
그렇다면 사용자가 사용할 수 있는 값(AUTO-INCREMENT 값)을 프라이머리 키로 설정하는 것이 좋을 것이다.  

또한 ROW 기반의 복제와 InnoDB Cluster에서는 모든 테이블이 프라이머리 키를 가져야만 하는 정상적인 복제 성능을 보장하기도 하므로 프라이머리 키는 꼭 생성하자.    
### AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
**세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고, 이를 프라이머리 키**로 설정하면 된다.  
이렇게 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 인조 식별자(surrogate key: 대체키) 라고 한다.  
**그리고 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO_INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다.**  
  
# 9. 유니크 인덱스
유니크는 사실 인덱스라기보다는 제약 조건에 가깝다고 볼 수 있다. 말 그대로 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데, **MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.**    
유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정 값이 아니므로 2개 이상 저장될 수 있다. MySQL에서 프라이머리 키는 기본적으로 **NULL을 허용하지 않는 유니크 속성**이 자동으로 부여된다.  
  
MyISAM이나 MEMORY 테이블에서 프라이머리 키는 사실 NULL이 허용되지 않는 유니크 인덱스와 같지만 InnoDB 테이블의 프라이머리 키는 클러스터링 키의 역할도 하므로 유니크 인덱스와는 근본적으로 다르다.  
  
## 9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교
유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없다.  
### 인덱스 읽기
유니크 인덱스가 빠르다고 생각하는데 이는 사실이 아니다.  
유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 때문에 느린 것이 아니라는 것이다.  
1개의 레코드를 읽느냐 2개 이상의 레코드를 읽느냐의 차이만 있다는 것을 의미할 뿐, 읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.  
### 인덱스 쓰기
새로운 레코드가 INSERT되거나 인덱스 칼럼의 값이 변경되는 경우에는 인덱스 쓰기 작업이 필요하다.  
그런데 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다. 그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.  
**그런데 MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 아주 빈번히 발생한다.**  
반드시 중복 체크를 해야하는 유니크 인덱스에서는 체인지 버퍼(인덱스 키의 저장을 버퍼링하기 위해)를 사용하지 못한다.이 때문에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느리게 작동한다.  
## 9.2 유니크 인덱스 사용 시 주의사항 
하나의 테이블에서 같은 칼럼에 유니크 인덱스와 일반 인덱스를 각각 중복해서 생성해 둔 경우가 가끔 있는데, **MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로** 중복해서 인덱스를 생성할 필요는 없다.
```sql
CREATE TABLE tb_unique (
  id INTEGER NOT NULL,
  nick_name VARCHAR(100),
  PRIMARY KEY(id),
  UNIQUE INDEX ux_nickname (nick_name),
  INDEX ix_nickname (nick_name)
);
```
다음과 같은 테이블에서 이미 nick_name이라는 칼럼에 대해서는 유니크 인덱스인 ux_nickname이 있기 때문에 ix_nickname 인덱스는 필요하지 않다.  
이미 유니크 인덱스도 일반 세컨더리 인덱스와 같은 역할을 동일하게 수행할 수 있으므로 다음과 같이 세컨더리 인덱스를 중복으로 만들어 줄 필요는 없다.  
  
똑같은 칼럼에 대해 프라이머리 키와 유니크 인덱스를 동일하게 생성한 경우도 있는데, 이 또한 불필요한 중복이므로 주의하자.  
  
결론적으로 유일성이 꼭 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 한 번씩 고려해 보자.  
```
프라이머리 키는 NULL을 허용하지 않으며 중복을 허용하지 않는다.
프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스(Secondary Index)로 분류한다. 유니크 인덱스는 대체 키라고도 하는데, 별도로 분류하기도 하고 그냥 세컨더리 인덱스로 분류하기도 한다.
```
# 10. 외래키
MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, **외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.**  
외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.  
  
InnoDB의 외래키 관리에는 중요한 두 가지 특징이 있다.  
- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.  
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.  
  
```sql
CREATE table tb_parent (
    id INT NOT NULL,
    fd VARCHAR(100) NOT NULL, PRIMARY KEY (id)
)ENGINE=InnoDB;

CREATE table tb_child (
    id INT NOT NULL,
    pid INT DEFAULT NULL, -- // parent.id 칼럼 참조
    fd VARCHAR(100) NOT NULL, PRIMARY KEY (id),
    KEY ix_parentid (pid),
    CONSTRAINT child_ibfk_1 FOREIGN KEY (pid) REFERENCES tb_parent (id) ON DELETE CASCADE
)ENGINE=InnoDB;

INSERT INTO tb_parent VALUES (1, 'parent-1'), (2, 'parent-2');
INSERT INTO tb_child VALUES (100, 1, 'child-100');
```
## 10.1 자식 테이블의 변경이 대기하는 경우
|작업 번호|커넥션-1|커넥션-2|
|------|---|---|
|1|BEGIN;||
|2|UPDATE tb_parent SET fd='changed-2' WHERE id=2;||
|3||BEGIN;|
|4||UPDATE tb_child SET pid=2 WHERE id=100;|
|5|ROLLBACK;||
|6||Query OK, 1 row affected|
  
이 작업에서는 1번 커넥션에서 먼저 트랜잭션을 시작하고 부모(tb_parent)에서 id가 2인 레코드에 UPDATE를 실행한다. 이 과정에서 1번 커넥션이 tb_parent 테이블에서 id가 2인 레코드에 대해서 쓰기 잠금을 획득한다. 그리고 2번 커넥션에서 자식 테이블의 `외래키 칼럼(부모의 키를 참조하는 칼럼)`인 pid를 2로 변경하는 쿼리를 실행해보자. 이 쿼리(작업번호 4번)는 부모 테이블의 변경 작업이 완료될 때까지 대기한다. 다시 1번 커넥션에서 트랜잭션을 종료하면 2번 커넥션의 대기 중이던 작업이 즉시 처리되는 것을 확인할 수 있다.  
  
**즉, 자식 테이블의 외래 키 칼럼의 변경(INSERT, UPDATE)은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 되는 것이다.** 자식 테이블의 외래키(pid)가 아닌 칼럼(tb_child의 fd와 같은)의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다.  
  
## 10.2 부모 테이블의 변경 작업이 대기하는 경우
|작업 번호|커넥션-1|커넥션-2|
|------|---|---|
|1|BEGIN;||
|2|UPDATE tb_child SET fd='changed-100' WHERE id=100;||
|3||BEGIN;|
|4||DELETE FROM tb_parent WHERE id=1;|
|5|ROLLBACK;||
|6||Query OK, 1 row affected|
첫 번째 커넥션에서 부모 키 "1"을 참조하는 자식 테이블의 레코드를 변경하면 tb_child테이블의 레코드에 대해 쓰기 잠금을 획득한다. 이 상태에서 2번 커넥션이 tb_parent 테이블에서 id가 1인 레코드를 삭제하는 경우(작업번호 4번)는 tb_child 테이블의 레코드에 대한 쓰기 잠금이 해제될 때까지 기다려야 한다. 이는 자식 테이블(tb_child)이 생성될 때 정의된 외래키의 특성(ON DELETE CASCADE) 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문이다.  
  
데이터베이스에서 외래 키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 모델링을 진행하는 것이 좋다.  
이처럼 물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 **해당 참조키가 부모 테이블에 있는지 확인**한다는 것은 이미 다들 알고 있을 것이다. 하지만 물리적인 외래키의 고려 사항은 이러한 체크 작업이 아니라 이러한 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 한다는 것이다. 또한 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미친다.  
