# 인덱스
인덱스에 대한 기본 지식은 개발자나 관리자에게 매우 중요한 부분이며, 쿼리 튜닝의 기본이 될 것이다.  
# 1. 디스크 읽기 방식
"랜덤(Random) I/O", "순차(Sequential) I/O"와 같은 디스크 읽기 방식을 먼저 간단히 알아보겠다.  
  
최근에는 자기 디스크 원판에 의존하는 하드 디스크보다 SSD 디스크가 많이 활용되고 있지만, 여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이라는 사실에는 변함이 없다.  
데이터베이스의 성능 튜닝은 어떻게 **디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.**  
  
## 1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
컴퓨터에서 CPU나 메모리 같은 주요 장치는 대부분 전자식 장치지만 하드 디스크 드라이브는 기계식 장치다. 그래서 데이터베이스 서버에서는 항상 디스크 장치가 병목이 된다.  
이러한 기계식 하드 디스크 드라이브를 대체하기 위해 전자식 저장 매체인 SSD(Solid State Drive)가 많이 출시되고 있다.  
SSD도 기존 하드 디스크 드라이브와 같은 인터페이스(SATA나 SAS)를 지원하므로 내장 디스크나 DAS 또는 SAN에 그대로 사용할 수 있다.  
  
SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)을 제거하고 그 대신 플래시 메모리를 장착하고 있다.  
플래시 메모리  
- 디스크 원판을 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다.  
- 전원이 공급되지 않아도 데이터가 삭제되지 않는다.  
- 컴퓨터의 메모리(D-Ram)보다는 느리지만 기계식 하드 디스크 드라이브보다는 훨씬 빠르다.  
  
DRAM과 SSD의 차이는 1000배 정도. 요즘은 DBMS 용으로 사용할 서버에는 대부분 SSD를 채택하고 있다.  
  
디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 하드 디스크 드라이브보다 조금 빠르거나 거의 비슷한 성능을 보이기도 한다. 하지만 SSD의 장점은 기존 하드 디스크 드라이브보다 랜덤 I/O가 훨씬 빠르다는 것이다. 데이터베이스 서버에서 **순차 I/O 작업은 그다지 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분**이므로 SSD의 장점은 DBMS용 스토리지에 최적이라고 볼 수 있다. 일반적인 웹 서비스(OLTP: OnLine Transaction Processing) 환경의 데이터베이스에서는 SSD가 하드 디스크 드라이브보다는 훨씬 빠르다.  
  
## 1.2 랜덤 I/O와 순차 I/O
랜덤 I/O 라는 표현은 하드 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미하는데, 사실, 순차 I/O 또한 이 작업 과정은 같다. 그렇다면 랜덤 I/O와 순차 I/O는 어떤 차이가 있을까?  
  
순차 I/O는 3개의 페이지(3 * 16KB)를 디스크에 기록하기 위해 1번 시스템 콜을 요청했지만, 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번 시스템 콜을 요청했다.  
즉, 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직였고, 랜덤 I/O는 디스크 헤드를 3번 움직였다.  
**디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.** 결국 순차 I/O는 랜덤 I/O보다 거의 3배정도 빠르다고 볼 수 있다. 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다고 볼 수 있다. 그래서 여러 번 쓰기 또는 읽기를 요청하는 랜덤 I/O 작업이 작업 부하가 훨씬 더 크다. 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.  
  
디스크 원판을 가지지 않는 SSD는 랜덤 I/O와 순차 I/O의 차이가 없을 것으로 예측하지만, 실제로는 그렇지 않다. SSD 드라이브에서도 랜덤 I/O는 여전히 순차 I/O보다 전체 스루풋(Throughput)이 떨어진다.  
```
Throughput: 단위 시간당 처리되는 작업의 수나 데이터 전송량
```
사실 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다. **일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.**  
**여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.**  
  
- 인덱스 레인지 스캔: 주로 랜덤 I/O 사용  
- 풀 테이블 스캔: 순차 I/O 사용  
그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.  
이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문인데, 이런 형태는 OLTP(On-Line Transaction Processing) 성격의 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다.  
  
랜덤 I/O나 순차 I/O 모두 파일에 쓰기를 실행하면 반드시 동기화(fsync 또는 flush)가 필요하다. 그런데 순차 I/O인 경우에도 이러한 파일 동기하 작업이 빈번히 발생한다면 랜덤 I/O와 같이 비효율적인 형태로 처리될 때가 많다. 기업용으로 사용하는 데이터베이스 서버에는 캐시 메모리가 장착된 RAID 컨트롤러가 일반적으로 사용되는데, RAID 컨트롤러의 캐시 메모리는 아주 빈번한 파일 동기화 작업이 호출되는 순차 I/O를 효율적으로 처리될 수 있게 변환하는 역할을 한다. 하드 디스크뿐만 아니라 SSD를 사용하는 경우에도 RAID 컨트롤러는 중요한 역할을 한다.  
# 2. 인덱스란?
책의 마지막 "찾아보기" - 인덱스  
책의 내용 - 데이터 파일  
책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유될 것이다.  
  
[칼럼(또는 칼럼들)의 값]과 [해당 레코드가 저장된 주소]를 키와 값의 쌍(key-Value pair)으로 삼아 인덱스 만든다.  
DBMS의 인덱스는 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.  
  
SortedList는 DBMS의 인덱스와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다.  
DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 **항상 정렬된 상태를 유지한다.** 데이터 파일은 저장된 순서대로 별도의 정렬 없이 그대로 저장해 둔다.  
  
DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 `INSERT나 UPDATE, DELETE` 문장의 처리가 느려진다. 하지만 이미 정렬된 "찾아보기"용 표(인덱스)를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리할 수 있다.  
결론적으로 DBMS는 `INSERT나 UPDATE, DELETE` 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.  
테이블의 인덱스를 하나 더 추가할지 말지  
- 데이터의 저장 속도를 어디까지 희생할 수 있는지  
- 읽기 속도를 얼마나 더 빠르게 만들어야 하는지  
  
에 따라 결정해야 한다. SELECT 쿼리 문장의 WHERE 조건절에 사용하는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.  
  
이 책에서는 키(Key)라는 말고 인덱스(Index)는 같은 의미로 사용하겠다.  
인덱스를 역할별로 구분해 본다면 프라이머리 키(Primary key)와 보조 키(세컨더리 인덱스, Secondary key)로 구분할 수 있다.  
  
대표적으로는 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.  
**B-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.** 위치 기반 검색을 지원하기 위한 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있다.  
**Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.** 하지만 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 경우 해시 인덱스를 사용할 수 없다. Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.  
  
유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다. 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.  
인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.  
유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.  
  
## 3.B-Tree 인덱스 

