# 12강 - 수치 연산
SQL은 컴퓨터를 조작하는 언어이기도 한 만큼 기본적으로 계산기능을 포함합니다.  
여기에서는 계산하는 방법, 특히 수치의 연산 방법에 대해 배워보겠습니다.  
  
`+-*/%MOD`  
## 1. 사칙 연산 
데이터베이스 제품에 따라 적용하는 함수가 다른데, % 대신 MOD 함수를 사용하는 경우도 있습니다.  
  
- *, /, % 연산자 : 우선순위 1  
- +, - 연산자 : 우선순위 2  
곱셈, 나눗셈, 나머지 그룹과 덧셈, 뺄셈 그룹으로 나뉩니다. 같은 그룹 내 연산자의 우선순위는 동일합니다.  
계산 순서는 연산자에 따라 관계없는 경우도 있지만 기본적으로 왼쪽에서 오른쪽으로 진행됩니다.  
우선순위가 다른 연산자들이 섞여있는 경우는 우선순위가 높은 쪽이 먼저 계산됩니다.  
  
## 2. SELECT 구로 연산하기
2장에서 SELECT 구에는 '열명을 지정한다'라고 배웠습니다만 이 외에도 여러 가지 식을 기술할 수 있습니다.  
이 식은 열명, 연산자, 상수로 구성됩니다.  
식을 기술할 수 있다는 것은 명령이 실행될 때 연산을 할 수 있다는 것을 의미합니다.  
  
`select *, price * quantity from sample34`  
  
## 3. 열의 별명
SELECT 결과에서 price * quantity라고 명명된 열이 금액을 계산한 부분입니다.  
  
이때 price * quantity와 같이 열 이름이 길고 알아보기 어려운 경우는 별명을 붙여 열명을 재지정할 수 있습니다.  
예를 들어 price * quantity에 amount라는 별명을 붙이면 조금 더 알아보기 쉬울 겁니다.  
  
`SELECT *, price * quantity AS amount FROM sample34;`  
별명은 예약어 AS를 사용해 지정합니다. SELECT 구에서는 콤마(,)로 구분해 복수의 식을 지정할 수 있으며 각각의 식에 별명을 붙일 수 있습니다.  
MySQL에서는 별명을 중복해서 지정해도 에러는 발생하지 않지만 프로그래밍 언어에서 결괏값의 처리 방식에 따라 문제가 발생할 수도 있습니다.  
기본적으로 중복되지 않도록 지정합니다.  
  
키워드 AS는 생략할 수 있습니다. `SELECT price * quantity amount`라고 써도 무방합니다.  
alias라고도 불리는 별명은 영어, 숫자, 한글 등으로 지정할 수 있습니다. 단 별명을 한글로 지정하는 경우에는 여러 가지로 오작동하는 경우가 많으므로  
더블쿼트(MySQL에서는 백쿼트)로 둘러싸서 지정합니다.  
이 룰은 데이터베이스 객체의 이름에 ASCII 문자 이외의 것을 사용할 경우에 해당합니다.  
  
더블쿼트로 둘러싸면 명령구문을 분석할 때 데이터베이스 객체의 이름이라고 간주합니다. 한편 싱글쿼트로 둘러싸는 것은 문자열 상수입니다.  
  
예약어를 더블쿼트로 둘러싸서 지정하면 사용할 수 있습니다.  
`SELECT price*quantity AS "SELECT" FROM sample34;`  
  
또한 이름을 붙일 때는 숫자로 시작할 수 없습니다. 수치형 상수를 명령 안에서 사용할 경우에는 쿼트로 묶지 않고 숫자만 입력합니다.  
이때 이름이 숫자로 시작한다면 그것이 수치형 상수를 의미하는 것인지 데이터베이스 객체명을 의미하는 것인지 구별할 수 없습니다.  
그에 따라 데이터베이스 객체명은 '숫자로 시작해서는 안 된다'는 제약이 생겼습니다. 물론 예약어와 겹칠 때와 마찬가지로 더블쿼트로 묶으면 피할 수 있습니다.  
  
다만 숫자만으로 구성되는 객체명은 허용되지 않습니다.  
한편 Oracle에서는 숫자로 시작하는 이름은 허용되지 않습니다. 데이터베이스 제품에 따라 미묘한 차이가 있습니다.  
더블쿼트로 둘러싸면 객체명으로 간주하는 룰은 표준 SQL에 규정되어 있습니다.  
  
## 4.WHERE 구에서 연산하기
`SELECT *, price * quantity AS amount FROM sample 34 WHERE price * quantity >= 2000;`  
여기서 price * quantity를 계산할 때 SELECT 구에서 amount 라는 별명을 붙였으므로 WHERE 구에서도 amount로 지정하면 되지 않을까 생각될 수도 있습니다.  
하지만 실제로 다음과 같은 SQL 명령을 실행해 보면 amount라는 열은 존재하지 않는다는 에러가 발생합니다.  
  
`SELECT *, price * quantity AS amount FROM sample 34 WHERE amount >= 2000;`  
### WHERE 구와 SELECT 구의 내부처리 순서
WHERE 구에서의 행 선택, SELECT 구에서의 열 선택은 데이터베이스 서버 내부에서 WHERE 구 -> SELECT 구의 순서로 처리됩니다.  
  
표준 SQL에는 내부처리 순서가 따로 정해져 있지 않습니다. 하지만 WHERE 구 -> SELECT 구의 순서로 내부 처리를 하는 데이터베이스가 많습니다.  
따라서 WHERE 구로 행이 조건에 일치하는지 아닌지를 먼저 조사한 후에 SELECT 구에 지정된 열을 선택해 결과로 반환하는 식으로 처리합니다.  
  
별명은 SELECT 구문을 내부 처리할 때 비로소 붙여집니다. 즉, WHERE 구의 처리는 SELECT 구보다 선행되므로 WHERE 구에서 사용한 별칭은  
아직 내부적으로 지정하지 않은 상태가 되어 에러가 발생하는 것입니다.  
  
1. WHERE 구에서 행을 추출한다.  
2. SELECT 구에서 열을 선택해 별명을 붙인다.  
  
SELECT 구에서 지정한 별명은 WHERE 구 안에서 사용할 수 없다!  
  
## 5. NULL 값의 연산
SQL에서는 NULL 값이 0으로 처리되지 않습니다.  
즉 NULL + 1의 결괏값은 1이 아닌 NULL입니다. 다음 연산결과 또한 모두 NULL이 됩니다.  
- NULL + 1  
- 1 + NULL  
- 1 + 2 * NULL  
- 1 / NULL  
통상적인 연산에서는 0으로 1을 나누면 'division by zero' 에러가 발생할 것입니다. 하지만 1 / NULL을 계산해도  
NULL이 0으로 처리되지 않아 에러가 발생하지 않고 결과는 NULL이 됩니다.  
  
## 6. ORDER BY 구에서 연산하기
ORDER BY 구에서도 연산할 수 있고 그 결괏값들을 정렬할 수 있습니다.  
`SELECT *, price * quantity AS amount FROM sample34 ORDER BY price * quantity DESC;`  
ORDER BY는 서버에서 내부적으로 가장 나중에 처리됩니다.  
즉, SELECT 구보다 나중에 처리되기 때문에 SELECT 구에서 지정한 별명을 ORDER BY에서도 사용할 수 있습니다.  
  
`SELECT *, price * quantity AS amount FROM sample34 ORDER BY amount DESC;`  
  
서버에서 내부처리는 다음과 같은 순으로 처리됩니다.  
WHERE 구 -> SELECT 구(별명을 지정) -> ORDER BY 구  
  
## 7. 함수
연산자 외에 함수를 사용해 연산할 수도 있습니다.  
`함수명(인수 1, 인수 2...)`  
  
함수는 함수명에 따라 연산 방법이 결정됩니다. 함수는 계산 대상을 인수로 지정합니다.  
10 % 3 -> 1  
MOD(10, 3) -> 1  
함수도 연산자도 표기 방법이 다를 뿐, 같은 것입니다.  
  
## 8. ROUND 함수
반올림을 할 때 사용되는 것이 ROUND 함수 입니다.  
`SELECT amount, ROUND(amount) FROM sample341;`  
INTEGER 형의 경우는 정수밖에 저장할 수 없기 때문에 amount 열은 DECIMAL 형으로 정의 하였습니다.  
DECIMAL 형은 열을 정의할 때 정수부와 소수부의 자릿수를 지정할 수 있는 자료형입니다.  
  
ROUND 함수는 기본적으로 소수점 첫째 자리를 기준으로 반올림한 값을 반환합니다.  
이때 ROUND 함수의 두 번째 인수로 반올림한 자릿수를 지정할 수 있습니다.  
해당 인수를 생략하는 경우 0으로 간주되고, 소수점 첫째 자리를 반올림합니다.  
1을 지정하면 소수점 둘째 자리를 반올림합니다.  
  
-1 : 1의 단위, -2 = 10의 단위, -3 = 10의 단위에서 반올림  
  
`SELECT amount, ROUND(amount, -2) FROM sample341;`  10단위를 반올림합니다.  