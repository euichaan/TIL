# 24강 - 상관 서브쿼리
서브쿼리의 일종인 '상관 서브쿼리'를 EXISTS 술어로 조합시켜서 서브쿼리를 사용하는 방법에 대해 알아보겠습니다.  
`EXISTS(SELECT 명령)`  
  
```SQL
UPDATE sample551 SET a = '있음' WHERE EXISTS (
  SELECT * FROM sample552 WHERE no2 = no
);
```
EXISTS 술어를 사용하면 서브쿼리가 반환하는 결괏값이 있는지를 조사할 수 있습니다.  
특히 EXISTS를 사용하는 경우에는 서브쿼리가 반드시 스칼라 값을 반환할 필요는 없습니다.  
EXISTS는 단지 반환된 행이 있는지를 확인해보고 값이 있으면 참, 없으면 거짓을 반환하므로 어떤 패턴이라도 상관없습니다.  
  
## 1. EXISTS
서브쿼리를 사용해 검색할 때 '데이터가 존재하는지 아닌지'판별하기 위해 조건을 지정할 수도 있습니다.  
이런 경우 EXISTS 술어를 사용해 조사할 수 있습니다.  
```SQL
UPDATE sample551 SET a = '있음' WHERE 
EXISTS (SELECT * FROM sample552 WHERE no2 = no);
```
EXISTS 술어에 서브쿼리를 지정하면 서브쿼리가 행을 반환할 경우에 참을 돌려줍니다.  
결과가 한 줄이라도 그 이상이라도 참이 됩니다. 반면 반환되는 행이 없을 경우에는 거짓이 됩니다.  
  
## 2. NOT EXISTS
'없음'의 경우 행이 존재하지 않는 상태가 참이 되므로 이때는 NOT EXISTS를 사용합니다.  
```SQL
UPDATE sample551 SET a = '없음' WHERE
NOT EXISTS (SELECT * FROM sample552 WHERE no2 = no);
```
이처럼 서브쿼리를 이용해 다른 테이블의 상황을 판단하고 UPDATE로 갱신할 수 있습니다.  
SELECT 명령이나 DELETE 명령으로도 서브쿼리를 사용할 수 있습니다.  
  
## 3. 상관 서브쿼리
```SQL
UPDATE sample551 SET a = '있음' WHERE EXISTS (
  SELECT * FROM sample552 WHERE no2 = no
);
```
UPDATE 명령(부모) 에서 WHERE 구에 괄호로 묶은 부분이 서브쿼리(자식)가 됩니다.  
부모 명령에서는 sample551를 갱신합니다. 자식인 서브쿼리에서는 sample552 테이블의 no2 열 값이 부모의 no 열 값과 일치하는 행을 검색합니다.  
이처럼 부모 명령과 자식인 서브쿼리가 특정 관계를 맺는 것을 '상관 서브쿼리'라 부릅니다.  
  
상관 서브쿼리가 아닌 단순한 서브쿼리는 단독 쿼리로 실행할 수 있습니다.  
하지만 상관 서브쿼리에서는 부모 명령과 연관되어 처리되기 때문에 서브쿼리 부분만을 따로 떼어내어 실행시킬 수 없습니다.  
  
열이 어느 테이블의 것인지 명시적으로 나타낼 필요가 있습니다. 열명 앞에 '테이블명.'을 붙이기만 하면 됩니다.  
```SQL
UPDATE sample551 SET a = '있음' WHERE EXISTS (
  SELECT * FROM sample552 WHERE sample552.no2 = sample551.no);
```
## 4. IN
스칼라 값끼리 비교할 때는 = 연산자를 사용합니다. 다만 집합을 비교할 때는 사용할 수 없습니다.  
IN을 사용하면 집합 안의 값이 존재하는지를 조사할 수 있습니다.  
서브쿼리를 사용할 때 IN을 사용하면 집합 안의 값이 존재하는지를 조사할 수 있습니다.  
  
`열명 IN(집합)`  
IN에서는 오른쪽에 집합을 지정합니다. 왼쪽에 지정된 값과 같은 값이 집합 안에 존재하면 참을 반환합니다.  
집합은 상수 리스트를 괄호로 묶어 기술합니다.  
```SQL
SELECT * FROM sample551 where no IN (3, 5);
```
한편, 집합 부분은 서브쿼리로도 지정할 수 있습니다.  
```SQL
SELECT * FROM sample551 WHERE no IN
 (SELECT no2 FROM sample552);
```
IN은 집합 안에 값이 포함되어 있으면 참이 됩니다. 반면 NOT IN으로 지정하면 집합에 값이 포함되어 있지 않을 경우 참이 됩니다.  
  
집계함수에서는 집합 안의 NULL 값을 무시하고 처리했습니다.  
IN에서는 집합 안에 NULL값이 있어도 무시하지는 않습니다. 다만 NULL = NULL을 제대로 계산할 수 없으므로 IN을 사용해도 NULL값은 비교할 수 없습니다.  
NULL을 비교할 때는 IS NULL을 사용해야 합니다.  
  
또한 NOT IN의 경우, 집합 안에 NULL 값이 있으면 설령 왼쪽 값이 집합 안에 포함되어 있지 않아도 참을 반환하지 않습니다.  
그 결과는 '불명(UNKNOWN)'이 됩니다.  
  
MySQL에서 집합에 NULL이 포함되어 있는 경우  
- 조건식 IN은 왼쪽 값이 집합에 포함되어 있으면 참을, 그렇지 않으면 NULL을 반환합니다.  
- 조건식 NOT IN은 왼쪽 값이 집합에 포함되어 있다면 거짓을, 그렇지 않으면 NULL을 반환합니다.  
NULL을 반환한다는 것은 비교할 수 없다는 것을 의미합니다.  
