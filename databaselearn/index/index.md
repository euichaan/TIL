# 인덱스
## 유니크 인덱스 
데이터의 중복 허용 여부로 분류하면 유니크 인덱스(Unique)와 유니크하지 않은 인덱스(Non-Unique)로 분류할 수 있다.  
인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다. **유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.**  
  
유니크는 사실 인덱스라기보다는 제약 조건에 가깝다고 볼 수 있다. 말 그대로 `테이블이나 인덱스`에 같은 값이 2개 이상 저장될 수 없음을 의미하는데, **MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.** 유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정 값이 아니므로 2개 이상 저장될 수 있다. MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동을 부여된다.  
  
유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없다.  
유니크 인덱스와 일반 세컨더리 인덱스의 읽기와 쓰기를 성능 관점에서 한번 살펴보자.  
  
### 인덱스 읽기
많은 사람이 유니크 인덱스가 빠르다고 생각한다. 하지만 이것은 사실이 아니다. 어떤 책에서는 유니크 인덱스는 1건만 읽으면 되지만 유니크하지 않은 세컨더리 인덱스에서는 레코드를 한 건 더 읽어야 하므로 느리다고 이야기한다. 하지만 유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 **CPU에서 칼럼값을 비교하는 작업**이기 때문에 이는 성능상 영향이 거의 없다고 볼 수 있다. 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 때문에 느린 것이 아니라는 것이다. 하나의 값을 검색하는 경우, 유니크 인덱스와 일반 세컨더리 인덱스는 사용되는 실행 계획이 다르다. 하지만 이는 인덱스의 성격이 유니크한지 아닌지에 따른 차이일 뿐 큰 차이는 없다.

### 인덱스 쓰기
**새로운 레코드가 INSERT**되거나 **인덱스 칼럼이 변경**되는 경우에는 인덱스 쓰기 작업이 필요하다.  
그런데 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다. 그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다. **그런데 MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금**을 사용하고, **쓰기를 할 때는 쓰기 잠금을** 사용하는데 이 과정에서 데드락이 아주 빈번히 발생한다. 또한 InnoDB 스토리지 엔진에서는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용된다. 그래서 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만, 안타깝게도 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못한다. 이 때문에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느리게 작동한다.  

## 인덱스 예상질문
### Index를 왜 모든 컬럼에 걸지 않는가?

### 인덱스 어떻게 걸었는지, 구조가 어떻게 되는지 (어떤 쿼리에 인덱스를 걸려고 했는지)
### 인덱스를 복합 인덱스로 걸 수도 있는데, 복합 인덱스 순서 거는 기준은? (컬럼 몇 개를 주고 복합 인덱스 어떻게 걸 것인지 묻는다)  
아래 내용은 Real MySQL 8.0 에서 가져왔습니다.  
  
**비교 작업의 범위를 좁히는 데 도움을 주는 순서로 인덱스를 걸어야 한다.**    
```SQL
SELECT * FROM dept_emp
WHERE dept_no = 'd002' AND emp_no >= 10144;
```
이 쿼리를 위해 dept_emp 테이블에 각각 칼럼의 순서만 다른 두 가지 케이스로 인덱스를 생성했다고 가정하자. 위의 쿼리가 처리되는 동안 각 인덱스에 어떤 차이가 있었는지 살펴보자.  
  
- 케이스 A: INDEX (dept_no, emp_no)  
- 케이스 B: INDEX (emp_no, dept_no)  
    
케이스 A 인덱스는 "dept_no='d002' AND emp_no >= 10144"인 레코드를 찾고, 그 이후에는 dept_no가 'd002'가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 된다. 이 경우에는 읽은 레코드가 모두 사용자가 원하는 결과임을 알 수 있다.  
하지만 케이스 B 인덱스는 우선 "emp_no >= 10144 AND dept_no='d002'"인 레코드를 찾고, 그 이후 모든 레코드에 대해 dept_no가 'd002'인지 비교하는 작업을 거쳐야 한다.  
  
이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 '필터링'이라고도 한다.  
'다중 칼럼 인덱스'의 정렬 방식(인덱스의 N번째 키 값은 N-1 번째 키 값에 대해서 다시 정렬됨)때문에 케이스 B에서는 추가적인 비교 과정이 필요하다. 케이스 A에서 2번째 칼럼인 emp_no는 비교 작업의 범위를 좁히는 데 도움을 준다. 하지만 케이스 B 인덱스에서 2번째 칼럼인 dept_no는 비교 작업의 범위를 좁히는 데 아무런 도움을 주지 못하고, 단지 쿼리의 조건에 맞는지 검사하는 용도로만 사용했다.  
  
공식적인 명칭은 아니지만 케이스 A 인덱스에서 두 조건(dept_no='d002'와 emp_no>=10144)과 같이 작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'이라 하고, 케이스 B 인덱스의 dept_no='d002' 조건과 같이 비교 작업의 범위를 좁히지 못하고 단순히 거름종이 역할만 하는 조건을 '필터링 조건' 또는 '체크 조건'이라고 표현한다. 결국 케이스 A 인덱스에서 dept_no 칼럼과 emp_no 칼럼은 모두 '작업 범위 결정 조건'에 해당하지만, 케이스 B 인덱스에서는 emp_no 칼럼만 '작업 범위 결정 조건이고, dept_no 칼럼은 '필터링 조건'으로 사용된 것이다.  
  
작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서(최종적으로 가져오는 레코드는 작게 만들지 몰라도) 쿼리의 처리 성능을 높이지는 못한다. 오히려 쿼리 실행을 더 느리게 만들 때가 많다.  
### DB 조회 성능 높이려면 어떻게 해야하나?


### 해시 테이블을 사용하는 인덱스 구조도 있는데 해시 테이블과 B-트리의 장단점은?