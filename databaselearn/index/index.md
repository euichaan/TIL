# 인덱스
## 인덱스 예상질문
### Index를 왜 모든 컬럼에 걸지 않는가?
모든 열에 인덱스 걸면 데이터를 저장하는 데 필요한 공간이 증가하고 쓰기 작업 속도가 느려지고 특정 유형의 쿼리에 대한 쿼리 성능이 크게 향상되지 않을 수 있기 때문에 단점이 있습니다. 쿼리 실행을 최적화하고 오버헤드를 최소화하기 위해서는 검색 조건이나 조인에 자주 사용되는 컬럼에 인덱스를 선택적으로 적용해야 합니다.
### 인덱스 어떻게 걸었는지, 구조가 어떻게 되는지 (어떤 쿼리에 인덱스를 걸려고 했는지)
```java 
public interface MemberRepository extends JpaRepository<Member, Long> {

	Optional<Member> findByEmail(String email);

	Optional<Member> findByRefreshToken(String refreshToken);

	Optional<Member> findByEmailAndMemberType(String email, MemberType memberType);
}
```
인덱스를 걸기 전 3번째 메서드의 쿼리를 실행 계획을 EXPLAIN 명령어로 살펴보면, type 칼럼(접근 방법)이 ALL로 나옵니다.(풀 테이블 스캔)  
```SQL
EXPLAIN SELECT * FROM member WHERE email='pine6971@gmail.com' AND memberType='KAKAO';
```
(email, memberType) 칼럼으로 유니크 인덱스를 생성했습니다. 비즈니스 로직에 (email, memberType)이 같은 회원은 한 개의 레코드만 존재하도록 유니크 제약조건이 필요했는데, MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없습니다.  
  
(email, memberType)으로 인덱스를 걸면서 비즈니스 요구사항도 같이 처리할 수 있었습니다.  
  
(email, memberType)의 칼럼 순서로 인덱스를 건 이유는, email의 카디널리티가 높기 때문입니다. 비즈니스 로직 상으로 같은 이메일이 최대 2개가 존재할 수 있기 때문에 email 칼럼으로 작업 범위를 더 많이 줄일 수 있습니다.  
  
MySQL에서 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이때 데드락이 아주 빈번히 발생합니다. 현재 InnoDB 스토리지 엔진을 사용하기 때문에 자동 데드락 감지 기능이 있어서 유니크 인덱스를 사용해도 괜찮다는 결정을 했습니다. InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그중 하나를 강제 종료합니다.  
  
유니크 인덱스를 건 후 EXPLAIN 명령어를 이용해 실행 계획을 살펴봤을 때 const 실행 계획을 사용하는 것으로 변경됐습니다.  
const 실행 계획은 테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식을 const라고 합니다. 백만개의 데이터 기준으로 0.79초에서 0.001초(1ms)의 성능 개선이 있었습니다.  
  
(email, memberType)의 다중 칼럼 인덱스로 인해 첫 번째 email로만 검색하는 쿼리는 ALL 실행 계획에서 ref의 실행 계획으로 변경됩니다. 유니크 인덱스를 구성하는 칼럼 중에서 일부만 동등 조건으로 WHERE 절에 명시됐기 때문에 해당 실행 계획이 나온 것을 확인할 수 있었습니다.  
  
refresh Token으로 회원을 조회하는 쿼리를 위해 (refresh_token)으로 인덱스를 생성했습니다. 마찬가지로 ref의 실행 계획으로 변경됐으며, 백만 개의 데이터 기준으로 1.3초에서 1.8ms의 성능 개선이 있었습니다.  
### 인덱스를 복합 인덱스로 걸 수도 있는데, 복합 인덱스 순서 거는 기준은? (컬럼 몇 개를 주고 복합 인덱스 어떻게 걸 것인지 묻는다)  
아래 내용은 Real MySQL 8.0 에서 가져왔습니다.  
  
**비교 작업의 범위를 좁히는 데 도움을 주는 순서로 인덱스를 걸어야 한다.**    
```SQL
SELECT * FROM dept_emp
WHERE dept_no = 'd002' AND emp_no >= 10144;
```
이 쿼리를 위해 dept_emp 테이블에 각각 칼럼의 순서만 다른 두 가지 케이스로 인덱스를 생성했다고 가정하자. 위의 쿼리가 처리되는 동안 각 인덱스에 어떤 차이가 있었는지 살펴보자.  
  
- 케이스 A: INDEX (dept_no, emp_no)  
- 케이스 B: INDEX (emp_no, dept_no)  
    
케이스 A 인덱스는 "dept_no='d002' AND emp_no >= 10144"인 레코드를 찾고, 그 이후에는 dept_no가 'd002'가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 된다. 이 경우에는 읽은 레코드가 모두 사용자가 원하는 결과임을 알 수 있다.  
하지만 케이스 B 인덱스는 우선 "emp_no >= 10144 AND dept_no='d002'"인 레코드를 찾고, 그 이후 모든 레코드에 대해 dept_no가 'd002'인지 비교하는 작업을 거쳐야 한다.  
  
이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 '필터링'이라고도 한다.  
'다중 칼럼 인덱스'의 정렬 방식(인덱스의 N번째 키 값은 N-1 번째 키 값에 대해서 다시 정렬됨)때문에 케이스 B에서는 추가적인 비교 과정이 필요하다. 케이스 A에서 2번째 칼럼인 emp_no는 비교 작업의 범위를 좁히는 데 도움을 준다. 하지만 케이스 B 인덱스에서 2번째 칼럼인 dept_no는 비교 작업의 범위를 좁히는 데 아무런 도움을 주지 못하고, 단지 쿼리의 조건에 맞는지 검사하는 용도로만 사용했다.  
  
공식적인 명칭은 아니지만 케이스 A 인덱스에서 두 조건(dept_no='d002'와 emp_no>=10144)과 같이 작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'이라 하고, 케이스 B 인덱스의 dept_no='d002' 조건과 같이 비교 작업의 범위를 좁히지 못하고 단순히 거름종이 역할만 하는 조건을 '필터링 조건' 또는 '체크 조건'이라고 표현한다. 결국 케이스 A 인덱스에서 dept_no 칼럼과 emp_no 칼럼은 모두 '작업 범위 결정 조건'에 해당하지만, 케이스 B 인덱스에서는 emp_no 칼럼만 '작업 범위 결정 조건이고, dept_no 칼럼은 '필터링 조건'으로 사용된 것이다.  
  
작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서(최종적으로 가져오는 레코드는 작게 만들지 몰라도) 쿼리의 처리 성능을 높이지는 못한다. 오히려 쿼리 실행을 더 느리게 만들 때가 많다.  
### DB 조회 성능 높이려면 어떻게 해야하나?
쿼리 최적화(inner join, 서브쿼리 대신 조인 사용 등), 인덱스, 역정규화 등 여러 방법이 있다.  
  
### 해시 테이블을 사용하는 인덱스 구조도 있는데 해시 테이블과 B-트리의 장단점은?
해시의 장점은 특정 값 일치 검색시 매우 빠르다. O(1), 충돌이 많을수록 O(N) 근접한다. 단점으로는 값을 변형해서 인덱싱하므로 전방 일치, 범위검색에서 사용 불가능하다.    
B-트리의 장점은 O(log N)으로 범위 검색이 가능하다. 단점은 특정 값 일치 검색시 hash보다 느리다.  

## 유니크 인덱스 
데이터의 중복 허용 여부로 분류하면 유니크 인덱스(Unique)와 유니크하지 않은 인덱스(Non-Unique)로 분류할 수 있다.  
인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다. **유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.**  
  
유니크는 사실 인덱스라기보다는 제약 조건에 가깝다고 볼 수 있다. 말 그대로 `테이블이나 인덱스`에 같은 값이 2개 이상 저장될 수 없음을 의미하는데, **MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.** 유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정 값이 아니므로 2개 이상 저장될 수 있다. MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동을 부여된다.  
  
유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없다.  
유니크 인덱스와 일반 세컨더리 인덱스의 읽기와 쓰기를 성능 관점에서 한번 살펴보자.  
  
### 인덱스 읽기
많은 사람이 유니크 인덱스가 빠르다고 생각한다. 하지만 이것은 사실이 아니다. 어떤 책에서는 유니크 인덱스는 1건만 읽으면 되지만 유니크하지 않은 세컨더리 인덱스에서는 레코드를 한 건 더 읽어야 하므로 느리다고 이야기한다. 하지만 유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 **CPU에서 칼럼값을 비교하는 작업**이기 때문에 이는 성능상 영향이 거의 없다고 볼 수 있다. 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 때문에 느린 것이 아니라는 것이다. 하나의 값을 검색하는 경우, 유니크 인덱스와 일반 세컨더리 인덱스는 사용되는 실행 계획이 다르다. 하지만 이는 인덱스의 성격이 유니크한지 아닌지에 따른 차이일 뿐 큰 차이는 없다. 1개의 레코드를 읽느냐 2개 이상의 레코드를 읽느냐의 차이만 있다는 것을 의미할 뿐, 읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.  
  
### 인덱스 쓰기
**새로운 레코드가 INSERT**되거나 **인덱스 칼럼이 변경**되는 경우에는 인덱스 쓰기 작업이 필요하다.  
그런데 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다. 그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다. **그런데 MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금**을 사용하고, **쓰기를 할 때는 쓰기 잠금을** 사용하는데 이 과정에서 데드락이 아주 빈번히 발생한다. 또한 InnoDB 스토리지 엔진에서는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용된다. 그래서 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만, 안타깝게도 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못한다. 이 때문에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느리게 작동한다.  
  
## 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List)형태로 관리한다. InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그중 하나를 강제 종료한다. 이때 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 트랜잭션의 언두 로그 양이며, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다. 트랜잭션이 언두 레코드를 적게 가졌다는 이야기는 롤백을 해도 언두 처리를 해야 할 내용이 적다는 것이며, 트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하도 덜 유발하기 때문이다.  
  
참고로 InnoDB 스토리지 엔진은 상위 레이어인 MySQL엔진에서 관리되는 테이블 잠금(LOCK TABLES 명령으로 잠긴 테이블)은 볼 수 없어서 데드락 감지가 불확실할 수도 있는데, innodb_table_locks 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있게 된다. **특별한 이유가 없다면 innodb_table_locks 시스템 변수를 활성화하자.**  
  
일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사해서 데드락을 찾아내는 작업은 크게 부담되지 않는다. 하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다. 데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 데드락 스레드를 찾게 된다. 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게 된다. 이렇게 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.  
  
이런 문제점을 해결하기 위해 MySQL 서버는 innodb_deadlock_detect 시스템 변수를 제공하며, innodb_deadlock_detect를 OFF로 설정하면 데드락 감지 스레드는 더는 작동하지 않게 된다. 데드락 감지 스레드가 작동하지 않으면 InnoDB 스토리지 엔진 내부에서 2개 이상이 상대방이 가진 잠금을 요구하는 상황(데드락 상황)이 발생해도 누군가가 중재를 하지 않기 때문에 무한정 대기하게 될 것이다.  
  
하지만 innodb_lock_wait_timeout 시스템 변수를 활성화하면 이런 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 된다. innodb_lock_wait_timeout 은 초 단위로 설정할 수 있으며, 잠금을 설정한 시간 동안 획독하지 못하면 쿼리는 실패하고 에러를 반환한다.  
## 실행 계획
MySQL 서버의 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인할 수 있다. MySQL 8.0 버전부터는 EXPLAIN EXTENDED, EXPLAIN PARTITIONS 명령은 문법에서 제거됐다. 그리고 MySQL 8.0 버전부터는 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택할 수 있다. (EXPLAIN FORMAT=TREE, EXPLAIN FORMAT=JSON)  

## type 칼럼   
쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.  
**여기서 방식이라 함은 인덱스를 사용해 레코드를 읽었는지, 아니면 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 레코드를 읽었는지 등을 의미한다.** 일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행 계획에서 type 칼럼은 반드시 체크해야 할 중요한 정보다.  
  
실행 계획의 type 칼럼에 표시될 수 있는 값은 현재 많이 사용되는 대부분의 버전에서 거의 차이 없이 다음과 같이 표시된다.  
- system  
- const  
- eq_ref  
- ref  
- fulltext  
- ref_or_null  
- unique_subquery  
- index_subquery  
- range  
- index_merge  
- index  
- ALL  
  
위의 12개 접근 방법 중에서 하단의 ALL을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다. ALL은 인덱스를 사용하지 않고, 테이블을 처음부터 끝까지 읽어서 레코드를 가져오는 풀 테이블 스캔 접근 방법을 의미한다. 하나의 단위 SELECT 쿼리는 위의 접근 방법 중에서 `단 하나`만 사용할 수 있다. 또한 index_merge를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다. 그러므로 실행 계획의 각 라인에 접근 방법이 2개 이상 표시되지 않으며, index_merge 이외의 type에서는 인덱스 항목에도 단 하나의 인덱스 이름만 표시된다.  
  
참고로 위에 표시된 각 접근 방법은 성능이 빠른 순서대로 나열된 것이다. MySQL 옵티마이저는 이러한 접근 방법과 비용을 함께 계산해서 최소의 비용이 필요한 접근 방법을 선택해 쿼리를 처리한다.  
  
이번 글에서는 위의 접근 방법 중 자주 나타나는 것들에 대해서 살펴보도록 하겠다.  
  
### 1.system
레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법을 system이라고 한다. 이 접근 방법은 InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.  
```SQL
CREATE TABLE tb_dual (fd1 int NOT NULL) ENGINE=MyISAM;
INSERT INTO tb_dual VALUES (1);
EXPLAIN SELECT * FROM tb_dual;
```
이 테이블을 InnoDB로 변환하면 접근 방법(type 칼럼)이 ALL 또는 index로 표시될 가능성이 크다. system은 테이블에 레코드가 1건 이하인 경우에만 사용할 수 있는 접근 방법이므로 실제 애플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.  
  
### 2. const
**테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식을 const라고 한다.**  
```SQL
EXPLAIN FORMAT=JSON
SELECT * FROM employees WHERE emp_no=10001;
```
다음 예제와 같이 다중 칼럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 칼럼만 조건으로 사용할 때는 const 타입의 조건 방법을 사용할 수 없다. 이 경우에는 실제 레코드가 1건만 저장돼 있더라도 MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확신할 수 없기 때문이다.  
```SQL
EXPLAIN
SELECT * FROM dept_emp WHERE dept_no='d005';
```
프라이머리 키의 일부만 조건으로 사용할 때는 type 칼럼에 const가 아닌 ref로 표시된다.  
하지만 프라이머리 키나 유니크 인덱스의 모든 칼럼을 동등 조건으로 WHERE 절에 명시하면 다음 예제와 같이 const 접근 방법을 사용한다.
```SQL
EXPLAIN
SELECT * FROM dept_emp WHERE dept_no='d005' AND emp_no=10001;
```
실행 계획의 type 칼럼이 const인 실행 계획은 MySQL의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화한다. 그래서 실행 계획의 type 칼럼의 값이 "상수(const)"로 표시되는 것이다. 다음의 예제 쿼리를 한 번 살펴보자.  
  
```SQL
EXPLAIN 
SELECT COUNT(*)
FROM employees e1
WHERE fisrt_name=(SELECT first_name FROM employees e2 WHERE emp_no=100001);
```
위의 예제 쿼리에서 e2 테이블은 프라이머리 키를 const 타입으로 접근한다. 실제 위 커리는 옵티마이저에 의해 최적화되는 시점에 다음과 같은 쿼리로 변환된다.  
```SQL
EXPLAIN 
SELECT COUNT(*)
FROM employees e1
WHERE fisrt_name='Jasminko'; -- // Jasminko는 사번이 100001인 사원의 first_name 값임
```
즉, 옵티마이저에 의해 상수화된 다음 쿼리 실행기로 전달되기 때문에 접근 방법이 const인 것이다.  
### 3.eq_ref
조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 동등(Equal) 조건 검색(두 번째 테이블은 반드시 1건의 레코드만 반환)  

### 4.ref
ref 접근 방법은 eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용된다. ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref 보다는 빠르지 않다. 하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다.  
  
```SQL
EXPLAIN
SELECT * FROM dept_emp WHERE dept_no='d005';
```
위의 예에서는 dept_emp 테이블의 프라이머리 키를 구성하는 칼럼(dept_no, emp_no) 중에서 일부만 동등(Equal) 조건으로 WHERE 절에 명시됐기 때문에 조건에 일치하는 레코드가 1건이라는 보장이 없다. 그래서 const가 아닌 ref 접근 방법이 사용됐다.  
  
const, eq_ref, ref 접근 방법 모두 WHERE 조건절에 사용하는 비교 연산자는 동등 비교 연산자여야 한다는 공통점이 있다.  
동등 비교 연산자는 "=" 또는 "<=>"을 의미한다. "<=>" 연산자는 NULL에 대한 비교 방식만 조금 다를 뿐 "=" 연산자와 다른 연산자다.  
  
또한 세 가지 모두 매우 좋은 접근 방법으로 인덱스의 분포도가 나쁘지 않다면 성능상의 문제를 일으키지 않는 접근 방법이다.  
쿼리를 튜닝할 때도 이 세 가지 접근 방법에 대해서는 크게 신경 쓰지 않고 넘어가도 무방하다.  
### 9.range
range는 우리가 익히 알고 있는 인덱스 레인지 스캔(검색해야 할 인덱스의 범위가 결정됐을 때 사용) 형태의 접근 방법이다.  
range는 하나의 값이 아니라 범위로 검색하는 경우를 의미하는데, 주로 "<, >, IS NULL, BETWEEN, IN, LIKE" 등의 연산자를 이용해 인덱스를 검색할 때 사용된다. 일반적으로 **애플리케이션의 쿼리가 가장 많이 사용**하는 접근 방법이다.  
  
얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.
### 11. index
index 접근 방법은 많은 사람이 자주 오해하는 접근 방법이다. index 접근 방법은 **인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔**을 의미한다.  
range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것은 아니라는 점을 잊지 말자.  
  
index 접근 방법은 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다.  
하지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔시 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 훨씬 효율적이라 할 수 있다.  
  
### 13. ALL
풀 테이블 스캔을 의미하는 접근 방법이다. 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거(체크 조건이 존재할 때)하고 반환한다.  
  
쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 사용하지 못하게 하는 것을 아니라는 점을 기억하자.  
  
일반적으로 index와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스 등과 같은 온라인 트랜잭션 처리 환경에는 적합하지 않다. 테이블이 매우 작지 않다면 실제로 테이블에 데이터를 어느 정도 저장한 상태에서 쿼리의 성능을 확인해 보고 적용하는 것이 좋다.  
